<?xml version="1.0"?>
<doc>
    <assembly>
        "ProjectedFSLib.Managed"
    </assembly>
    <members>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.MarkDirectoryAsVirtualizationRoot(System.String,System.Guid)">
            <summary>
Marks an existing directory as the provider's virtualization root.
</summary>
            <remarks>
A provider may wish to designate its virtualization root before it is ready or able to
instantiate the <see cref="T:Microsoft.Windows.ProjFS.VirtualizationInstance" /> class.  In that case it may use this
method to designate the root.  The provider must generate a GUID to identify the virtualization
instance and pass it in <paramref name="virtualizationInstanceGuid" />.  The
<see cref="T:Microsoft.Windows.ProjFS.VirtualizationInstance" /> constructor will use that
value to identify the provider to ProjFS.
</remarks>
            <param name="rootPath">
The full path to the directory to mark as the virtualization root.
</param>
            <param name="virtualizationInstanceGuid">
A GUID generated by the provider.  ProjFS uses this value to internally identify the provider.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the conversion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="rootPath" /> is an empty string.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Directory" /> if <paramref name="rootPath" /> does not specify a directory.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.ReparsePointEncountered" /> if <paramref name="rootPath" /> is already a placeholder or some other kind of reparse point.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" /> if <paramref name="rootPath" /> is an ancestor or descendant of an existing virtualization root.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.MarkDirectoryAsPlaceholder(System.String,System.Byte[],System.Byte[])">
            <summary>
Converts an existing directory to a hydrated directory placeholder.
</summary>
            <remarks>
Children of the directory are not affected.
</remarks>
            <param name="targetDirectoryPath">
The full path (i.e. not relative to the virtualization root) to the directory to convert
to a placeholder.
</param>
            <param name="contentId">
                <para>
A content identifier, generated by the provider. This value is used to distinguish between
different versions of the same file, for example different file contents and/or metadata
(e.g. timestamps) for the same file path.
</para>
                <para>
This value must be at most <see cref="P:Microsoft.Windows.ProjFS.VirtualizationInstance.PlaceholderIdLength" /> bytes in size.  Any data
beyond that length will be discarded.
</para>
            </param>
            <param name="providerId">
                <para>
Optional provider-specific data.  The provider may use this value as its own unique identifier,
for example as a version number for the format of the <paramref name="contentId" /> value.
</para>
                <para>
This value must be at most <see cref="P:Microsoft.Windows.ProjFS.VirtualizationInstance.PlaceholderIdLength" /> bytes in size.  Any data
beyond that length will be discarded.
</para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the conversion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="targetDirectoryPath" /> is an empty string
or if it is not a directory path.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.ReparsePointEncountered" /> if <paramref name="targetDirectoryPath" />
is already a placeholder or some other kind of reparse point.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CreateWriteBuffer(System.UInt64,System.UInt32,System.UInt64@,System.UInt32@)">
            <summary>
Creates a <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> for use with <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</summary>
            <remarks>
                <para>
    The <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> object ensures that any alignment requirements of the
    underlying storage device are met when writing data with the <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />
    method.
    </para>
                <para>
    This overload allows a provider to get sector-aligned values for the start offset and
    length of the write.  The provider uses <paramref name="alignedByteOffset" /> and
    <paramref name="alignedLength" /> to copy the correct data out of its backing store
    into the <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> and transfer it when calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
    </para>
                <para>
    Note that unlike most methods on <see cref="T:Microsoft.Windows.ProjFS.VirtualizationInstance" />, this method
    throws rather than return <see cref="T:Microsoft.Windows.ProjFS.HResult" />.  This makes it convenient to use
    in constructions like a <c>using</c> clause.
    </para>
            </remarks>
            <param name="byteOffset">
Byte offset from the beginning of the file at which the provider wants to write data.
</param>
            <param name="length">
The number of bytes to write to the file.
</param>
            <param name="alignedByteOffset">
                <paramref name="byteOffset" />, aligned to the sector size of the storage device.  The
provider uses this value as the <c>byteOffset</c> parameter to <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</param>
            <param name="alignedLength">
                <paramref name="length" />, aligned to the sector size of the storage device.  The
provider uses this value as the <c>length</c> parameter to <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</param>
            <returns>
A <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> that provides the needed capacity.
</returns>
            <exception cref="T:System.ComponentModel.Win32Exception">
An error occurred retrieving the sector size from ProjFS.
</exception>
            <exception cref="T:System.OutOfMemoryException">
A buffer could not be allocated.
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CreateWriteBuffer(System.UInt32)">
            <summary>
Creates a <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> for use with <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</summary>
            <remarks>
                <para>
    The <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> object ensures that any alignment requirements of the
    underlying storage device are met when writing data with the <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />
    method.
    </para>
                <para>
    Note that unlike most methods on <see cref="T:Microsoft.Windows.ProjFS.VirtualizationInstance" />, this method
    throws rather than return <see cref="T:Microsoft.Windows.ProjFS.HResult" />.  This makes it convenient to use
    in constructions like a <c>using</c> clause.
    </para>
            </remarks>
            <param name="desiredBufferSize">
The size in bytes of the buffer required to write the data.
</param>
            <returns>
A <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> that provides at least <paramref name="desiredBufferSize" />
bytes of capacity.
</returns>
            <exception cref="T:System.OutOfMemoryException">
A buffer could not be allocated.
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CompleteCommand(System.Int32,Microsoft.Windows.ProjFS.NotificationType)">
            <summary>
Signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <param name="newNotificationMask">
                <para>
Used when completing <c>Microsoft.Windows.ProjFS.Notify*</c> callbacks that have a
<c>notificationMask</c> parameter.  Specifies a bitwise-OR of <see cref="T:Microsoft.Windows.ProjFS.NotificationType" />
values indicating the set of notifications the provider wishes to receive for this file.
</para>
                <para>
If the provider sets this value to 0, it is equivalent to specifying
<see cref="F:Microsoft.Windows.ProjFS.NotificationType.UseExistingMask" />.
</para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback
    or if <paramref name="newNotificationMask" /> is not a valid combination of <see cref="T:Microsoft.Windows.ProjFS.NotificationType" />
    values.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CompleteCommand(System.Int32,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)">
            <summary>
Signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <param name="results">
Used when completing <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.Boolean,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)" />.  Receives
the results of the enumeration.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback or
    if <paramref name="results" /> is not a valid <see cref="T:Microsoft.Windows.ProjFS.IDirectoryEnumerationResults" />.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CompleteCommand(System.Int32,Microsoft.Windows.ProjFS.HResult)">
            <summary>
Signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <param name="completionResult">
The final status of the operation.  See the descriptions for the callback delegates for
appropriate return codes.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CompleteCommand(System.Int32)">
            <summary>
Signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.UpdateFileIfNeeded(System.String,System.DateTime,System.DateTime,System.DateTime,System.DateTime,System.IO.FileAttributes,System.Int64,System.Byte[],System.Byte[],Microsoft.Windows.ProjFS.UpdateType,Microsoft.Windows.ProjFS.UpdateFailureCause@)">
            <summary>
Updates an item that has been cached on the local file system.
</summary>
            <remarks>
                <para>
This routine cannot be called on a virtual file or directory.
</para>
                <para>
If the file or directory to be updated is in any state other than "placeholder", the provider
must specify an appropriate combination of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values in the
<paramref name="updateFlags" /> parameter.  This helps guard against accidental loss of
data, since upon successful return from this routine the item becomes a placeholder with
the updated metadata.  Any metadata that had been changed since the placeholder was created,
or any file data it contained is discarded.
</para>
                <para>
Note that the timestamps the provider specifies in the <paramref name="creationTime" />,
<paramref name="lastAccessTime" />, <paramref name="lastWriteTime" />, and <paramref name="changeTime" />
parameters may be any values the provider wishes.  This allows the provider to preserve
the illusion of files and directories that already exist on the user's system even before they
are physically created on the user's disk.
</para>
            </remarks>
            <param name="relativePath">
The path, relative to the virtualization root, to the file or directory to updated.
</param>
            <param name="creationTime">
The time the file was created.
</param>
            <param name="lastAccessTime">
The time the file was last accessed.
</param>
            <param name="lastWriteTime">
The time the file was last written to.
</param>
            <param name="changeTime">
The time the file was last changed.
</param>
            <param name="fileAttributes">
The file attributes.
</param>
            <param name="endOfFile">
The size of the file in bytes.
</param>
            <param name="contentId">
                <para>
A content identifier, generated by the provider.  ProjFS will pass this value back to the
provider when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.
This allows the provider to distinguish between different versions of the same file, i.e.
different file contents and/or metadata for the same file path.
</para>
                <para>
If this parameter specifies a content identifier that is the same as the content identifier
already on the file or directory, the call succeeds and no update takes place.  Otherwise,
if the call succeeds then the value of this parameter replaces the existing content identifier
on the file or directory.
</para>
                <para>
This value must be at most <see cref="P:Microsoft.Windows.ProjFS.VirtualizationInstance.PlaceholderIdLength" /> bytes in size.  Any data
beyond that length will be discarded.
</para>
            </param>
            <param name="providerId">
                <para>
Optional provider-specific data.  ProjFS will pass this value back to the provider
when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.  The
provider may use this value as its own unique identifier, for example as a version number
for the format of the <paramref name="contentId" /> value.
</para>
                <para>
This value must be at most <see cref="P:Microsoft.Windows.ProjFS.VirtualizationInstance.PlaceholderIdLength" /> bytes in size.  Any data
beyond that length will be discarded.
</para>
            </param>
            <param name="updateFlags">
                <para>
A combination of 0 or more <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values to control whether ProjFS
should allow the update given the state of the file or directory on disk.  See the documentation
of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> for a description of each flag and what it will allow.
</para>
                <para>
If the item is a dirty placeholder, full file, or tombstone, and the provider does not
specify the appropriate flag(s), this routine will fail to update the item.
</para>
            </param>
            <param name="failureReason">
If this method fails with <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" />, this receives a
<see cref="T:Microsoft.Windows.ProjFS.UpdateFailureCause" /> value that describes the reason the update failed.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the update succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="relativePath" /> is an empty string.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> if <paramref name="relativePath" /> cannot
    be found.  It may be for a virtual file or directory.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.PathNotFound" /> if <paramref name="relativePath" /> contains
    an intermediate component that cannot be found.  The path may terminate beneath a
    directory that has been replaced with a tombstone.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.DirNotEmpty" /> if <paramref name="relativePath" /> is a
    directory and is not empty.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" /> if the input value of <paramref name="updateFlags" />
    does not allow the update given the state of the file or directory on disk.  The value
    of <paramref name="failureReason" /> indicates the cause of the failure.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WritePlaceholderInfo(System.String,System.DateTime,System.DateTime,System.DateTime,System.DateTime,System.IO.FileAttributes,System.Int64,System.Boolean,System.Byte[],System.Byte[])">
            <summary>
Sends file or directory metadata to ProjFS.
</summary>
            <remarks>
                <para>
    The provider uses this method to create a placeholder on disk.  It does this when ProjFS
    calls the provider's implementation of <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />,
    or the provider may use this method to proactively lay down a placeholder.
    </para>
                <para>
    Note that the timestamps the provider specifies in the <paramref name="creationTime" />,
    <paramref name="lastAccessTime" />, <paramref name="lastWriteTime" />, and <paramref name="changeTime" />
    parameters may be any values the provider wishes.  This allows the provider to preserve
    the illusion of files and directories that already exist on the user's system even before they
    are physically created on the user's disk.
    </para>
            </remarks>
            <param name="relativePath">
                <para>
    The path, relative to the virtualization root, of the file or directory.
    </para>
                <para>
    If the provider is processing a call to <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />,
    then this must be a match to the <c>relativePath</c> value passed in that call.  The
    provider should use the <see cref="M:Microsoft.Windows.ProjFS.Utils.FileNameCompare(System.String,System.String)" /> method to determine whether
    the two names match.
    </para>
                <para>
    For example, if <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" /> specifies
    <c>dir1\dir1\FILE.TXT</c> in <c>relativePath</c>, and the providerâ€™s backing store contains
    a file called <c>File.txt</c> in the <c>dir1\dir2</c> directory, and <see cref="M:Microsoft.Windows.ProjFS.Utils.FileNameCompare(System.String,System.String)" />
    returns 0 when comparing the names <c>FILE.TXT</c> and <c>File.txt</c>, then the provider
    specifies <c>dir1\dir2\File.txt</c> as the value of this parameter.
    </para>
            </param>
            <param name="creationTime">
The time the file was created.
</param>
            <param name="lastAccessTime">
The time the file was last accessed.
</param>
            <param name="lastWriteTime">
The time the file was last written to.
</param>
            <param name="changeTime">
The time the file was last changed.
</param>
            <param name="fileAttributes">
The file attributes.
</param>
            <param name="endOfFile">
The size of the file in bytes.
</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory, <c>false</c> otherwise.
</param>
            <param name="contentId">
                <para>
    A content identifier, generated by the provider.  ProjFS will pass this value back to the
    provider when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.
    This allows the provider to distinguish between different versions of the same file, i.e.
    different file contents and/or metadata for the same file path.
    </para>
                <para>
    This value must be at most <see cref="P:Microsoft.Windows.ProjFS.VirtualizationInstance.PlaceholderIdLength" /> bytes in size.  Any data
    beyond that length will be discarded.
    </para>
            </param>
            <param name="providerId">
                <para>
    Optional provider-specific data.  ProjFS will pass this value back to the provider
    when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.  The
    provider may use this value as its own unique identifier, for example as a version number
    for the format of the <paramref name="contentId" /> value.
    </para>
                <para>
    This value must be at most <see cref="P:Microsoft.Windows.ProjFS.VirtualizationInstance.PlaceholderIdLength" /> bytes in size.  Any data
    beyond that length will be discarded.
    </para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the placeholder information was successfully written.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="relativePath" /> is an empty string.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.DeleteFile(System.String,Microsoft.Windows.ProjFS.UpdateType,Microsoft.Windows.ProjFS.UpdateFailureCause@)">
            <summary>
Enables a provider to delete a file or directory that has been cached on the local file system.
</summary>
            <remarks>
                <para>
    If the item is still in the provider's store, deleting it from the local file system changes
    it to a virtual item.
    </para>
                <para>
    This routine will fail if called on a file or directory that is already virtual.
    </para>
                <para>
    If the file or directory to be deleted is in any state other than "placeholder", the
    provider must specify an appropriate combination of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values
    in the <paramref name="updateFlags" /> parameter.  This helps guard against accidental
    loss of data. If the provider did not specify a combination of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" />
    values in the <paramref name="updateFlags" /> parameter that would allow the delete
    to happen, the method fails with <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" />.
    </para>
                <para>
    If a directory contains only tombstones, it may be deleted using this method and
    specifying <see cref="F:Microsoft.Windows.ProjFS.UpdateType.AllowTombstone" /> in <paramref name="updateFlags" />.
    If the directory contains non-tombstone files, then this method will return <see cref="F:Microsoft.Windows.ProjFS.HResult.DirNotEmpty" />.
    </para>
            </remarks>
            <param name="relativePath">
The path, relative to the virtualization root, to the file or directory to delete.
</param>
            <param name="updateFlags">
                <para>
    A combination of 0 or more <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values to control whether ProjFS
    should allow the delete given the state of the file or directory on disk.  See the documentation
    of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> for a description of each flag and what it will allow.
    </para>
                <para>
    If the item is a dirty placeholder, full file, or tombstone, and the provider does not
    specify the appropriate flag(s), this routine will fail to delete the placeholder.
    </para>
            </param>
            <param name="failureReason">
If this method fails with <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" />, this receives a
<see cref="T:Microsoft.Windows.ProjFS.UpdateFailureCause" /> value that describes the reason the delete failed.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the delete succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="relativePath" /> is an empty string.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> if <paramref name="relativePath" /> cannot
    be found.  It may be for a virtual file or directory.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.PathNotFound" /> if <paramref name="relativePath" /> contains
    an intermediate component that cannot be found.  The path may terminate beneath a
    directory that has been replaced with a tombstone.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.DirNotEmpty" /> if <paramref name="relativePath" /> is a
    directory and is not empty.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" /> if the input value of <paramref name="updateFlags" />
    does not allow the delete given the state of the file or directory on disk.  The value
    of <paramref name="failureReason" /> indicates the cause of the failure.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Sends file contents to ProjFS.
</summary>
            <remarks>
                <para>
    The provider uses this method to provide the data requested when ProjFS calls the provider's
    implementation of <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" />.
    </para>
                <para>
    The provider calls <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CreateWriteBuffer(System.UInt32)" /> to create an instance of <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" />
    to contain the data to be written.  The <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> ensures that any alignment
    requirements of the underlying storage device are met.
    </para>
            </remarks>
            <param name="dataStreamId">
Identifier for the data stream to write to.  The provider must use the value of
<paramref name="dataStreamId" /> passed in its <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" />
callback.
</param>
            <param name="buffer">
A <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> created using <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CreateWriteBuffer(System.UInt32)" /> that contains
the data to write.
</param>
            <param name="byteOffset">
Byte offset from the beginning of the file at which to write the data.
</param>
            <param name="length">
The number of bytes to write to the file.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the data was successfully written.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="buffer" /> is not specified,
    <paramref name="length" /> is 0, or <paramref name="byteOffset" /> is greater than the
    length of the file.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Handle" /> if <paramref name="dataStreamId" /> does not
    correspond to a placeholder that is expecting data to be provided.</para>
            </returns>
            <seealso cref="T:Microsoft.Windows.ProjFS.WriteBuffer" />
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.ClearNegativePathCache(System.UInt32@)">
            <summary>
Purges the virtualization instance's negative path cache, if it is active.
</summary>
            <remarks>
                <para>
    If the negative path cache is active, then if the provider indicates that a file path does
    not exist by returning <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> from its implementation of
    <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />
    then ProjFS will fail subsequent opens of that path without calling
    <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" /> again.
    </para>
                <para>
    To resume receiving <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" /> for
    paths the provider has indicated do not exist, the provider must call this method.
    </para>
            </remarks>
            <param name="totalEntryNumber">
Returns the number of paths that were in the cache before it was purged.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the the cache was successfully purged.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StopVirtualizing">
            <summary>
Stops the virtualization instance, making it unavailable to service I/O or invoke callbacks
on the provider.
</summary>
            <exception cref="T:System.InvalidOperationException">
The virtualization instance is in an invalid state (it may already be stopped).
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)">
            <summary>
Starts the virtualization instance, making it available to service I/O and invoke callbacks
on the provider.
</summary>
            <remarks>
                <para>
    If the provider has implemented any optional callback delegates, it must set their
    implementations into the <c>On...</c> properties prior to calling this method.
    </para>
                <para>
    On Windows 10 version 1803 this method attempts to determine the sector alignment
    requirements of the underlying storage device and stores that information internally
    in the <see cref="T:Microsoft.Windows.ProjFS.VirtualizationInstance" /> instance.  This information is required
    by the <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.CreateWriteBuffer(System.UInt32)" /> method to ensure that it can return data in
    the <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" /> method when the original reader is using unbuffered
    I/O.  If this method cannot determine the sector alignment requirements of the
    underlying storage device, it will throw a <see cref="T:System.IO.IOException" />
    exception.
    </para>
                <para>
    On Windows 10 version 1809 and later versions the alignment requirements are determined
    by the system.
    </para>
            </remarks>
            <param name="requiredCallbacks">
                <para>
    The provider's implementation of the <see cref="T:Microsoft.Windows.ProjFS.IRequiredCallbacks" /> interface.
    </para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the virtualization instance started successfully.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" /> if the virtualization root is an ancestor or descendant of an existing virtualization root.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.AlreadyInitialized" /> if the virtualization instance is already running.</para>
            </returns>
            <exception cref="T:System.IO.IOException">
The sector alignment requirements of the volume could not be determined.  See the Remarks section.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.PlaceholderIdLength">
            <summary>Returns the maximum allowed length of a placeholder's contentID or provider ID.</summary>
            <remarks>
See <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.WritePlaceholderInfo(System.String,System.DateTime,System.DateTime,System.DateTime,System.DateTime,System.IO.FileAttributes,System.Int64,System.Boolean,System.Byte[],System.Byte[])" /> or <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.UpdateFileIfNeeded(System.String,System.DateTime,System.DateTime,System.DateTime,System.DateTime,System.IO.FileAttributes,System.Int64,System.Byte[],System.Byte[],Microsoft.Windows.ProjFS.UpdateType,Microsoft.Windows.ProjFS.UpdateFailureCause@)" /> for more information.
</remarks>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.VirtualizationInstanceId">
            <summary>Allows the provider to retrieve the virtualization instance GUID.</summary>
            <remarks>
A virtualization instance is identified with a GUID.  If the provider did not generate
and store a GUID itself using the <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.MarkDirectoryAsVirtualizationRoot(System.String,System.Guid)" /> method,
then the VirtualizationInstance class generates one for it.  Either way, the provider
can retrieve the GUID via this property.
</remarks>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.RequiredCallbacks">
            <summary>Retrieves the <see cref="T:Microsoft.Windows.ProjFS.IRequiredCallbacks" /> interface.</summary>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyFilePreConvertToFull(Microsoft.Windows.ProjFS.NotifyFilePreConvertToFullCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyFilePreConvertToFull">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFilePreConvertToFullCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFilePreConvertToFullCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file is about to be converted from a placeholder to a full file. </para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyFileHandleClosedFileModifiedOrDeleted(Microsoft.Windows.ProjFS.NotifyFileHandleClosedFileModifiedOrDeletedCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyFileHandleClosedFileModifiedOrDeleted">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedFileModifiedOrDeletedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedFileModifiedOrDeletedCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file handle has been closed on a modified file, or the file was deleted as a result
of closing the handle.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyFileHandleClosedNoModification(Microsoft.Windows.ProjFS.NotifyFileHandleClosedNoModificationCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyFileHandleClosedNoModification">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedNoModificationCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedNoModificationCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file handle has been closed and the file has not been modified.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyHardlinkCreated(Microsoft.Windows.ProjFS.NotifyHardlinkCreatedCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyHardlinkCreated">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyHardlinkCreatedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyHardlinkCreatedCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a hard link has been created for a file.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyFileRenamed(Microsoft.Windows.ProjFS.NotifyFileRenamedCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyFileRenamed">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileRenamedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileRenamedCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file has been renamed.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyPreCreateHardlink(Microsoft.Windows.ProjFS.NotifyPreCreateHardlinkCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyPreCreateHardlink">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyPreCreateHardlinkCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyPreCreateHardlinkCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a hard link is about to be created for a file.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyPreRename(Microsoft.Windows.ProjFS.NotifyPreRenameCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyPreRename">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyPreRenameCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyPreRenameCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file is about to be renamed.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyPreDelete(Microsoft.Windows.ProjFS.NotifyPreDeleteCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyPreDelete">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyPreDeleteCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyPreDeleteCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file is about to be deleted.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyFileOverwritten(Microsoft.Windows.ProjFS.NotifyFileOverwrittenCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyFileOverwritten">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileOverwrittenCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileOverwrittenCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file has been superseded or overwritten.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyNewFileCreated(Microsoft.Windows.ProjFS.NotifyNewFileCreatedCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyNewFileCreated">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyNewFileCreatedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyNewFileCreatedCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a new file has been created.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnNotifyFileOpened(Microsoft.Windows.ProjFS.NotifyFileOpenedCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnNotifyFileOpened">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileOpenedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileOpenedCallback" />
            <remarks>
                <para>The provider is not required to provide an implementation of this callback.
If it does not provide this callback, the provider will not receive notifications when
a file has been opened.</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnCancelCommand(Microsoft.Windows.ProjFS.CancelCommandCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnCancelCommand">
            <summary>Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" />
            <remarks>
                <para>
If the provider wishes to support asynchronous processing of callbacks (that is, if it
intends to return <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> from any of its callbacks), then the provider
must set this property prior to calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</para>
                <para>
If the provider does not wish to support asynchronous processing of callbacks, then it
is not required to provide an implementation of this callback.
</para>
                <para>If the provider does implement this callback, then it must set this property prior to
calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.set_OnQueryFileName(Microsoft.Windows.ProjFS.QueryFileNameCallback)">
            <exception cref="T:System.InvalidOperationException">
The provider has already called <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.VirtualizationInstance.OnQueryFileName">
            <summary>
Stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.QueryFileNameCallback" />.
</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.QueryFileNameCallback" />
            <remarks>The provider must set this property prior to calling <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)" />.</remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.VirtualizationInstance.#ctor(System.String,System.UInt32,System.UInt32,System.Boolean,System.Collections.Generic.IReadOnlyCollection{Microsoft.Windows.ProjFS.NotificationMapping})">
            <summary>
Initializes an object that manages communication between a provider and ProjFS.
</summary>
            <remarks>
                <para>
    If <paramref name="virtualizationRootPath" /> doesn't already exist, this constructor
    will create it and mark it as the virtualization root.  The constructor will generate
    a GUID to serve as the virtualization instance ID.
    </para>
                <para>
    If <paramref name="virtualizationRootPath" /> does exist, this constructor will check
    for a ProjFS reparse point.  If the reparse point does not exist, <c>virtualizationRootPath</c>
    will be marked as the virtualization root.  If it has a different reparse point then
    the constructor will throw a <see cref="T:System.ComponentModel.Win32Exception" /> for
    ERROR_REPARSE_TAG_MISMATCH.
    </para>
                <para>
    For providers that create their virtualization root separately from instantiating the
    <c>VirtualizationInstance</c> class, the static method
    <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.MarkDirectoryAsVirtualizationRoot(System.String,System.Guid)" /> is provided.
    </para>
            </remarks>
            <param name="virtualizationRootPath">
    The full path to the virtualization root directory.  If this directory does not already
    exist, it will be created.  See the Remarks section for further details.
</param>
            <param name="poolThreadCount">
                <para>
    The number of threads the provider will have available to process callbacks from ProjFS.
    </para>
                <para>
    If the provider specifies 0, ProjFS will use a default value of 2 * <paramref name="concurrentThreadCount" />.
    </para>
            </param>
            <param name="concurrentThreadCount">
                <para>
    The maximum number of threads the provider wants to run concurrently to process callbacks
    from ProjFS.
    </para>
                <para>
    If the provider specifies 0, ProjFS will use a default value equal to the number of
    CPU cores in the system.
    </para>
            </param>
            <param name="enableNegativePathCache">
                <para>
    If <c>true</c>, specifies that the virtualization instance should maintain a "negative
    path cache".  If the negative path cache is active, then if the provider indicates
    that a file path does not exist by returning <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> from its
    implementation of <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />, then ProjFS will
    fail subsequent opens of that path without calling <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />
    again.
    </para>
                <para>
    To resume receiving <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" /> for paths the provider has
    indicated do not exist, the provider must call <see cref="M:Microsoft.Windows.ProjFS.VirtualizationInstance.ClearNegativePathCache(System.UInt32@)" />.
    </para>
            </param>
            <param name="notificationMappings">
                <para>
    A collection of zero or more <see cref="T:Microsoft.Windows.ProjFS.NotificationMapping" /> objects that describe the
    notifications the provider wishes to receive for the virtualization root.
    </para>
                <para>
    If the collection is empty, ProjFS will send the notifications <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileOpened" />,
    <see cref="F:Microsoft.Windows.ProjFS.NotificationType.NewFileCreated" />, and <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileOverwritten" />
    for all files and directories under the virtualization root.
    </para>
            </param>
            <exception cref="T:System.IO.FileLoadException">
The native ProjFS library (ProjectedFSLib.dll) is not available.
</exception>
            <exception cref="T:System.EntryPointNotFoundException">
An expected entry point cannot be found in ProjectedFSLib.dll.
</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">
An error occurred in setting up the virtualization root.
</exception>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.VirtualizationInstance">
            <summary>
Provides methods and callbacks that allow a provider to interact with a virtualization instance.
</summary>
            <remarks>
                <para>
The provider creates one instance of this class for each virtualization root that it manages.
The provider uses this class's properties and methods to receive and respond to callbacks from
ProjFS for its virtualization instance, and to send commands that control the virtualization
instance's state.
</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.MarkDirectoryAsPlaceholder(System.String,System.Byte[],System.Byte[])">
            <summary>
When overridden in a derived class, converts an existing directory to a hydrated directory
placeholder.
</summary>
            <remarks>
Children of the directory are not affected.
</remarks>
            <param name="targetDirectoryPath">
The full path (i.e. not relative to the virtualization root) to the directory to convert
to a placeholder.
</param>
            <param name="contentId">
                <para>
A content identifier, generated by the provider. This value is used to distinguish between
different versions of the same file, for example different file contents and/or metadata
(e.g. timestamps) for the same file path.
</para>
            </param>
            <param name="providerId">
                <para>
Optional provider-specific data.  The provider may use this value as its own unique identifier,
for example as a version number for the format of the <paramref name="contentId" /> value.
</para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the conversion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="targetDirectoryPath" /> is an empty string
or if it is not a directory path.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.ReparsePointEncountered" /> if <paramref name="targetDirectoryPath" />
is already a placeholder or some other kind of reparse point.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CreateWriteBuffer(System.UInt64,System.UInt32,System.UInt64@,System.UInt32@)">
            <summary>
When overridden in a derived class, creates a <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> for use with <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</summary>
            <remarks>
                <para>
    The <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> object ensures that any alignment requirements of the
    underlying storage device are met when writing data with the <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />
    method.
    </para>
                <para>
    This overload allows a provider to get sector-aligned values for the start offset and
    length of the write.  The provider uses <paramref name="alignedByteOffset" /> and
    <paramref name="alignedLength" /> to copy the correct data out of its backing store
    into the <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> and transfer it when calling <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
    </para>
            </remarks>
            <param name="byteOffset">
Byte offset from the beginning of the file at which the provider wants to write data.
</param>
            <param name="length">
The number of bytes to write to the file.
</param>
            <param name="alignedByteOffset">
                <paramref name="byteOffset" />, aligned to the sector size of the storage device.  The
provider uses this value as the <c>byteOffset</c> parameter to <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</param>
            <param name="alignedLength">
                <paramref name="length" />, aligned to the sector size of the storage device.  The
provider uses this value as the <c>length</c> parameter to <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</param>
            <returns>
A <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> that provides the needed capacity.
</returns>
            <exception cref="T:System.ComponentModel.Win32Exception">
An error occurred retrieving the sector size from ProjFS.
</exception>
            <exception cref="T:System.OutOfMemoryException">
A buffer could not be allocated.
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CreateWriteBuffer(System.UInt32)">
            <summary>
When overridden in a derived class, creates a <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> for use with
<see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />.
</summary>
            <remarks>
                <para>
    The <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> object ensures that any alignment requirements of the
    underlying storage device are met when writing data with the <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)" />
    method.
    </para>
            </remarks>
            <param name="desiredBufferSize">
The size in bytes of the buffer required to write the data.
</param>
            <returns>
A <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> that provides at least <paramref name="desiredBufferSize" />
bytes of capacity.
</returns>
            <exception cref="T:System.OutOfMemoryException">
A buffer could not be allocated.
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CompleteCommand(System.Int32,Microsoft.Windows.ProjFS.NotificationType)">
            <summary>
When overridden in a derived class, signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <param name="newNotificationMask">
                <para>
Used when completing <c>Microsoft.Windows.ProjFS.Notify*</c> callbacks that have a
<c>notificationMask</c> parameter.  Specifies a bitwise-OR of <see cref="T:Microsoft.Windows.ProjFS.NotificationType" />
values indicating the set of notifications the provider wishes to receive for this file.
</para>
                <para>
If the provider sets this value to 0, it is equivalent to specifying
<see cref="F:Microsoft.Windows.ProjFS.NotificationType.UseExistingMask" />.
</para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback
    or if <paramref name="newNotificationMask" /> is not a valid combination of <see cref="T:Microsoft.Windows.ProjFS.NotificationType" />
    values.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CompleteCommand(System.Int32,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)">
            <summary>
When overridden in a derived class, signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <param name="results">
Used when completing <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.Boolean,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)" />.  Receives
the results of the enumeration.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback or
    if <paramref name="results" /> is not a valid <see cref="T:Microsoft.Windows.ProjFS.IDirectoryEnumerationResults" />.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CompleteCommand(System.Int32,Microsoft.Windows.ProjFS.HResult)">
            <summary>
When overridden in a derived class, signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <param name="completionResult">
The final status of the operation.  See the descriptions for the callback delegates for
appropriate return codes.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CompleteCommand(System.Int32)">
            <summary>
When overridden in a derived class, signals to ProjFS that the provider has completed processing a callback from which it
previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</summary>
            <remarks>
If the provider calls this method for the <paramref name="commandId" /> passed by the
<see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" /> callback it is not an error, however it is a no-op
because the I/O that caused the callback invocation identified by <paramref name="commandId" />
has already ended.
</remarks>
            <param name="commandId">
A value that uniquely identifies the callback invocation to complete.  This value must be
equal to the value of the <paramref name="commandId" /> parameter of the callback from
which the provider previously returned <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" />.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if completion succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="commandId" /> does not specify a pended callback.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.UpdateFileIfNeeded(System.String,System.DateTime,System.DateTime,System.DateTime,System.DateTime,System.IO.FileAttributes,System.Int64,System.Byte[],System.Byte[],Microsoft.Windows.ProjFS.UpdateType,Microsoft.Windows.ProjFS.UpdateFailureCause@)">
            <summary>
When overridden in a derived class, updates an item that has been cached on the local
file system.
</summary>
            <remarks>
                <para>
This routine cannot be called on a virtual file or directory.
</para>
                <para>
If the file or directory to be updated is in any state other than "placeholder", the provider
must specify an appropriate combination of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values in the
<paramref name="updateFlags" /> parameter.  This helps guard against accidental loss of
data, since upon successful return from this routine the item becomes a placeholder with
the updated metadata.  Any metadata that had been changed since the placeholder was created,
or any file data it contained is discarded.
</para>
                <para>
Note that the timestamps the provider specifies in the <paramref name="creationTime" />,
<paramref name="lastAccessTime" />, <paramref name="lastWriteTime" />, and <paramref name="changeTime" />
parameters may be any values the provider wishes.  This allows the provider to preserve
the illusion of files and directories that already exist on the user's system even before they
are physically created on the user's disk.
</para>
            </remarks>
            <param name="relativePath">
The path, relative to the virtualization root, to the file or directory to updated.
</param>
            <param name="creationTime">
The time the file was created.
</param>
            <param name="lastAccessTime">
The time the file was last accessed.
</param>
            <param name="lastWriteTime">
The time the file was last written to.
</param>
            <param name="changeTime">
The time the file was last changed.
</param>
            <param name="fileAttributes">
The file attributes.
</param>
            <param name="endOfFile">
The size of the file in bytes.
</param>
            <param name="contentId">
                <para>
A content identifier, generated by the provider.  ProjFS will pass this value back to the
provider when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.
This allows the provider to distinguish between different versions of the same file, i.e.
different file contents and/or metadata for the same file path.
</para>
                <para>
If this parameter specifies a content identifier that is the same as the content identifier
already on the file or directory, the call succeeds and no update takes place.  Otherwise,
if the call succeeds then the value of this parameter replaces the existing content identifier
on the file or directory.
</para>
            </param>
            <param name="providerId">
                <para>
Optional provider-specific data.  ProjFS will pass this value back to the provider
when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.  The
provider may use this value as its own unique identifier, for example as a version number
for the format of the <paramref name="contentId" /> value.
</para>
            </param>
            <param name="updateFlags">
                <para>
A combination of 0 or more <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values to control whether ProjFS
should allow the update given the state of the file or directory on disk.  See the documentation
of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> for a description of each flag and what it will allow.
</para>
                <para>
If the item is a dirty placeholder, full file, or tombstone, and the provider does not
specify the appropriate flag(s), this routine will fail to update the item.
</para>
            </param>
            <param name="failureReason">
If this method fails with <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" />, this receives a
<see cref="T:Microsoft.Windows.ProjFS.UpdateFailureCause" /> value that describes the reason the update failed.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the update succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="relativePath" /> is an empty string.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> if <paramref name="relativePath" /> cannot
    be found.  It may be for a virtual file or directory.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.PathNotFound" /> if <paramref name="relativePath" /> contains
    an intermediate component that cannot be found.  The path may terminate beneath a
    directory that has been replaced with a tombstone.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.DirNotEmpty" /> if <paramref name="relativePath" /> is a
    directory and is not empty.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" /> if the input value of <paramref name="updateFlags" />
    does not allow the update given the state of the file or directory on disk.  The value
    of <paramref name="failureReason" /> indicates the cause of the failure.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WritePlaceholderInfo(System.String,System.DateTime,System.DateTime,System.DateTime,System.DateTime,System.IO.FileAttributes,System.Int64,System.Boolean,System.Byte[],System.Byte[])">
            <summary>
When overridden in a derived class, sends file or directory metadata to ProjFS.
</summary>
            <remarks>
                <para>
    The provider uses this method to create a placeholder on disk.  It does this when ProjFS
    calls the provider's implementation of <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />,
    or the provider may use this method to proactively lay down a placeholder.
    </para>
                <para>
    Note that the timestamps the provider specifies in the <paramref name="creationTime" />,
    <paramref name="lastAccessTime" />, <paramref name="lastWriteTime" />, and <paramref name="changeTime" />
    parameters may be any values the provider wishes.  This allows the provider to preserve
    the illusion of files and directories that already exist on the user's system even before they
    are physically created on the user's disk.
    </para>
            </remarks>
            <param name="relativePath">
                <para>
    The path, relative to the virtualization root, of the file or directory.
    </para>
                <para>
    If the provider is processing a call to <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />,
    then this must be a match to the <c>relativePath</c> value passed in that call.  The
    provider should use the <see cref="M:Microsoft.Windows.ProjFS.Utils.FileNameCompare(System.String,System.String)" /> method to determine whether
    the two names match.
    </para>
                <para>
    For example, if <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" /> specifies
    <c>dir1\dir1\FILE.TXT</c> in <c>relativePath</c>, and the providerâ€™s backing store contains
    a file called <c>File.txt</c> in the <c>dir1\dir2</c> directory, and <see cref="M:Microsoft.Windows.ProjFS.Utils.FileNameCompare(System.String,System.String)" />
    returns 0 when comparing the names <c>FILE.TXT</c> and <c>File.txt</c>, then the provider
    specifies <c>dir1\dir2\File.txt</c> as the value of this parameter.
    </para>
            </param>
            <param name="creationTime">
The time the file was created.
</param>
            <param name="lastAccessTime">
The time the file was last accessed.
</param>
            <param name="lastWriteTime">
The time the file was last written to.
</param>
            <param name="changeTime">
The time the file was last changed.
</param>
            <param name="fileAttributes">
The file attributes.
</param>
            <param name="endOfFile">
The size of the file in bytes.
</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory, <c>false</c> otherwise.
</param>
            <param name="contentId">
                <para>
    A content identifier, generated by the provider.  ProjFS will pass this value back to the
    provider when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.
    This allows the provider to distinguish between different versions of the same file, i.e.
    different file contents and/or metadata for the same file path.
    </para>
            </param>
            <param name="providerId">
                <para>
    Optional provider-specific data.  ProjFS will pass this value back to the provider
    when requesting file contents in the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" /> callback.  The
    provider may use this value as its own unique identifier, for example as a version number
    for the format of the <paramref name="contentId" /> value.
    </para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the placeholder information was successfully written.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="relativePath" /> is an empty string.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.DeleteFile(System.String,Microsoft.Windows.ProjFS.UpdateType,Microsoft.Windows.ProjFS.UpdateFailureCause@)">
            <summary>
When overridden in a derived class, enables a provider to delete a file or directory that
has been cached on the local file system.
</summary>
            <remarks>
                <para>
    If the item is still in the provider's store, deleting it from the local file system changes
    it to a virtual item.
    </para>
                <para>
    This routine will fail if called on a file or directory that is already virtual.
    </para>
                <para>
    If the file or directory to be deleted is in any state other than "placeholder", the
    provider must specify an appropriate combination of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values
    in the <paramref name="updateFlags" /> parameter.  This helps guard against accidental
    loss of data. If the provider did not specify a combination of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" />
    values in the <paramref name="updateFlags" /> parameter that would allow the delete
    to happen, the method fails with <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" />.
    </para>
                <para>
    If a directory contains only tombstones, it may be deleted using this method and
    specifying <see cref="F:Microsoft.Windows.ProjFS.UpdateType.AllowTombstone" /> in <paramref name="updateFlags" />.
    If the directory contains non-tombstone files, then this method will return <see cref="F:Microsoft.Windows.ProjFS.HResult.DirNotEmpty" />.
    </para>
            </remarks>
            <param name="relativePath">
The path, relative to the virtualization root, to the file or directory to delete.
</param>
            <param name="updateFlags">
                <para>
    A combination of 0 or more <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> values to control whether ProjFS
    should allow the delete given the state of the file or directory on disk.  See the documentation
    of <see cref="T:Microsoft.Windows.ProjFS.UpdateType" /> for a description of each flag and what it will allow.
    </para>
                <para>
    If the item is a dirty placeholder, full file, or tombstone, and the provider does not
    specify the appropriate flag(s), this routine will fail to delete the placeholder.
    </para>
            </param>
            <param name="failureReason">
If this method fails with <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" />, this receives a
<see cref="T:Microsoft.Windows.ProjFS.UpdateFailureCause" /> value that describes the reason the delete failed.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the delete succeeded.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="relativePath" /> is an empty string.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> if <paramref name="relativePath" /> cannot
    be found.  It may be for a virtual file or directory.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.PathNotFound" /> if <paramref name="relativePath" /> contains
    an intermediate component that cannot be found.  The path may terminate beneath a
    directory that has been replaced with a tombstone.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.DirNotEmpty" /> if <paramref name="relativePath" /> is a
    directory and is not empty.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" /> if the input value of <paramref name="updateFlags" />
    does not allow the delete given the state of the file or directory on disk.  The value
    of <paramref name="failureReason" /> indicates the cause of the failure.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.WriteFileData(System.Guid,Microsoft.Windows.ProjFS.IWriteBuffer,System.UInt64,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
When overridden in a derived class, sends file contents to ProjFS.
</summary>
            <remarks>
                <para>
    The provider uses this method to provide the data requested when ProjFS calls the provider's
    implementation of <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" />.
    </para>
                <para>
    The provider calls <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CreateWriteBuffer(System.UInt32)" /> to create an instance of <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" />
    to contain the data to be written.  The <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> ensures that any alignment
    requirements of the underlying storage device are met.
    </para>
            </remarks>
            <param name="dataStreamId">
Identifier for the data stream to write to.  The provider must use the value of
<paramref name="dataStreamId" /> passed in its <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)" />
callback.
</param>
            <param name="buffer">
A <see cref="T:Microsoft.Windows.ProjFS.WriteBuffer" /> created using <see cref="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.CreateWriteBuffer(System.UInt32)" /> that contains
the data to write.
</param>
            <param name="byteOffset">
Byte offset from the beginning of the file at which to write the data.
</param>
            <param name="length">
The number of bytes to write to the file.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the data was successfully written.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InvalidArg" /> if <paramref name="buffer" /> is not specified,
    <paramref name="length" /> is 0, or <paramref name="byteOffset" /> is greater than the
    length of the file.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Handle" /> if <paramref name="dataStreamId" /> does not
    correspond to a placeholder that is expecting data to be provided.</para>
            </returns>
            <seealso cref="T:Microsoft.Windows.ProjFS.WriteBuffer" />
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.ClearNegativePathCache(System.UInt32@)">
            <summary>
When overridden in a derived class, purges the virtualization instance's negative path
cache, if it is active.
</summary>
            <remarks>
                <para>
    If the negative path cache is active, then if the provider indicates that a file path does
    not exist by returning <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> from its implementation of
    <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" />
    then ProjFS will fail subsequent opens of that path without calling
    <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" /> again.
    </para>
                <para>
    To resume receiving <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)" /> for
    paths the provider has indicated do not exist, the provider must call this method.
    </para>
            </remarks>
            <param name="totalEntryNumber">
Returns the number of paths that were in the cache before it was purged.
</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the the cache was successfully purged.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.StopVirtualizing">
            <summary>
When overridden in a derived class, stops the virtualization instance, making it unavailable
to service I/O or invoke callbacks on the provider.
</summary>
            <exception cref="T:System.InvalidOperationException">
The virtualization instance is in an invalid state (it may already be stopped).
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IVirtualizationInstance.StartVirtualizing(Microsoft.Windows.ProjFS.IRequiredCallbacks)">
            <summary>
When overridden in a derived class, starts a ProjFS virtualization instance, making it
available to service I/O and invoke callbacks on the provider.
</summary>
            <param name="requiredCallbacks">
                <para>
    The provider's implementation of the <see cref="T:Microsoft.Windows.ProjFS.IRequiredCallbacks" /> interface.
    </para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the virtualization instance started successfully.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /> if a buffer could not be allocated to communicate with ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp" /> if the virtualization root is an ancestor or descendant of an existing virtualization root.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.AlreadyInitialized" /> if the virtualization instance is already running.</para>
            </returns>
            <exception cref="T:System.IO.IOException">
The sector alignment requirements of the volume could not be determined.  See the Remarks section.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyFilePreConvertToFull">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFilePreConvertToFullCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFilePreConvertToFullCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyFileHandleClosedFileModifiedOrDeleted">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedFileModifiedOrDeletedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedFileModifiedOrDeletedCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyFileHandleClosedNoModification">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedNoModificationCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedNoModificationCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyHardlinkCreated">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyHardlinkCreatedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyHardlinkCreatedCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyFileRenamed">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileRenamedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileRenamedCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyPreCreateHardlink">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyPreCreateHardlinkCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyPreCreateHardlinkCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyPreRename">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyPreRenameCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyPreRenameCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyPreDelete">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyPreDeleteCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyPreDeleteCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyFileOverwritten">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileOverwrittenCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileOverwrittenCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyNewFileCreated">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyNewFileCreatedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyNewFileCreatedCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnNotifyFileOpened">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.NotifyFileOpenedCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.NotifyFileOpenedCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnCancelCommand">
            <summary>When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" />.</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.CancelCommandCallback" />
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IVirtualizationInstance.OnQueryFileName">
            <summary>
When overridden in a derived class, stores the provider's implementation of <see cref="T:Microsoft.Windows.ProjFS.QueryFileNameCallback" />.
</summary>
            <seealso cref="T:Microsoft.Windows.ProjFS.QueryFileNameCallback" />
        </member>
        <member name="T:Microsoft.Windows.ProjFS.IVirtualizationInstance">
            <summary>
Interface to allow for easier unit testing of a virtualization provider.
</summary>
            <remarks>
This class defines the interface implemented by the <c>ProjFS.VirtualizationInstance</c> class.
This interface class is provided for use by unit tests to mock up the interface to ProjFS.
</remarks>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.NotificationMapping.NotificationRoot">
            <summary>
A path to a directory, relative to the virtualization root.  The virtualization root itself
must be specified as an empty string.
</summary>
            <value>
ProjFS will send to the provider the notifications specified in <see cref="P:Microsoft.Windows.ProjFS.NotificationMapping.NotificationMask" />
for this directory and its descendants.
</value>
            <exception cref="T:System.ArgumentException">
The notification root value is <c>.</c> or begins with <c>.\\</c>.  The notification root
must be specified relative to the virtualization root, with the virtualization root itself
specified as an empty string.
</exception>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.NotificationMapping.NotificationMask">
            <summary>
A bit vector of <c>NotificationType</c> values.
</summary>
            <value>
ProjFS will send to the provider the specified notifications for operations performed on
the directory specified by the <see cref="P:Microsoft.Windows.ProjFS.NotificationMapping.NotificationRoot" /> property and its descendants.
</value>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.NotificationMapping.#ctor(Microsoft.Windows.ProjFS.NotificationType,System.String)">
            <summary>
Initializes a new instance of the <see cref="T:Microsoft.Windows.ProjFS.NotificationMapping" /> class with the 
specified property values.
</summary>
            <param name="notificationMask">The set of notifications that ProjFS should return for the
virtualization root specified in <paramref name="notificationRoot" />.</param>
            <param name="notificationRoot">The path to the notification root, relative to the virtualization
root.  The virtualization root itself must be specified as an empty string.</param>
            <exception cref="T:System.ArgumentException">
                <paramref name="notificationRoot" /> is <c>.</c> or begins with <c>.\\</c>.  <paramref name="notificationRoot" />
must be specified relative to the virtualization root, with the virtualization root itself
specified as an empty string.
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.NotificationMapping.#ctor">
            <summary>
Initializes a new instance of the <see cref="T:Microsoft.Windows.ProjFS.NotificationMapping" /> class with the 
<see cref="P:Microsoft.Windows.ProjFS.NotificationMapping.NotificationRoot" /> property set to the virtualization root (i.e. <c>null</c>)
and the <see cref="P:Microsoft.Windows.ProjFS.NotificationMapping.NotificationMask" /> property set to <see cref="F:Microsoft.Windows.ProjFS.NotificationType.None" />.
</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotificationMapping">
            <summary>
Represents a path relative to a virtualization root and the notification bit mask that should apply to it.
</summary>
            <remarks>
                <para>
A <see cref="T:Microsoft.Windows.ProjFS.NotificationMapping" /> object describes a "notification mapping", which is a pairing between a directory
(referred to as a "notification root") and a set of notifications, expressed as a bit mask, which
ProjFS should send for that directory and its descendants.
</para>
                <para>
The provider passes zero or more <see cref="T:Microsoft.Windows.ProjFS.NotificationMapping" /> objects to the <paramref name="notificationMappings" />
parameter of the <c>VirtualizationInstance::StartVirtualizing</c> method to configure
notifications for the virtualization root.
</para>
                <para>
If the provider does not specify any notification mappings, ProjFS will default to sending the
notifications <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileOpened" />, <see cref="F:Microsoft.Windows.ProjFS.NotificationType.NewFileCreated" />,
and <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileOverwritten" /> for all files and directories
in the virtualization instance.
</para>
                <para>
The <see cref="P:Microsoft.Windows.ProjFS.NotificationMapping.NotificationRoot" /> property holds the notification root.  It is specified
relative to the virtualization root, with an empty string representing the virtualization root
itself.
</para>
                <para>
If the provider specifies multiple notification mappings, and some are descendants of others,
the mappings must be specified in descending depth.  Notification mappings at deeper levels
override higher-level mappings for their descendants.
</para>
                <para>
For example, consider the following virtualization instance layout, with C:\VirtRoot as the
virtualization root:
<code>
C:\VirtRoot
+--- baz
\--- foo
     +--- subdir1
     \--- subdir2
</code>
The provider wants:
<list type="bullet"><item><description>Notification of new file/directory creates for most of the virtualization instance</description></item><item><description>Notification of new file/directory creates, file opens, and file deletes for C:\VirtRoot\foo</description></item><item><description>No notifications for C:\VirtRoot\foo\subdir1</description></item></list>
The provider could describe this with the following pseudocode:
<code>
List&lt;NotificationMapping&gt; notificationMappings = new List&lt;NotificationMapping&gt;()
{
    // Configure default notifications
    new NotificationMapping(NotificationType.NewFileCreated,
                            string.Empty),
    // Configure notifications for C:\VirtRoot\foo
    new NotificationMapping(NotificationType.NewFileCreated | NotificationType.FileOpened | NotificationType.FileHandleClosedFileDeleted,
                            "foo"),
    // Configure notifications for C:\VirtRoot\foo\subdir1
    new NotificationMapping(NotificationType.None,
                            "foo\\subdir1"),
};

// Call VirtualizationRoot.StartVirtualizing() passing in the notificationMappings List.
</code></para>
            </remarks>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.UpdateFailureCause">
            <summary>
Defines values that describe why an attempt to update or delete a file in a virtualization
root has failed.
</summary>
            <remarks>
These values are used in the <paramref name="failureReason" /> output parameter of 
<c>ProjFS.VirtualizationInstance.UpdateFileIfNeeded</c> and <c>ProjFS.VirtualizationInstance.DeleteFile</c>.
These are set if the API returns <c>HResult.VirtualizationInvalidOp</c> because the file state
does not allow the operation with the <paramref name="updateFlags" /> value(s) passed to the API.
</remarks>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateFailureCause.ReadOnly">
            <summary>
The item had the DOS read-only bit set and the provider did not specify <c>UpdateType.AllowReadOnly.</c></summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateFailureCause.DirtyData">
            <summary>
The item was a full file and the provider did not specify <c>UpdateType.AllowDirtyData</c>.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateFailureCause.DirtyMetadata">
            <summary>
The item was a dirty placeholder (hydrated or not), and the provider did not specify
<c>UpdateType.AllowDirtyMetadata</c>.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateFailureCause.NoFailure">
            <summary>
The update did not fail.
</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyFilePreConvertToFullCallback">
            <summary>
Indicates that the file is about to be converted from a placeholder to a full file, i.e. its
contents are likely to be modified.
</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyFilePreConvertToFull</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FilePreConvertToFull" />
    when it started the virtualization instance.</para>
                <para>If the provider returns <c>false</c>, then the file system will return
    STATUS_ACCESS_DENIED from the operation that triggered the conversion, and the placeholder
    will not be converted to a full file.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <returns>
                <para>
                    <c>true</c> if the provider wants to allow the file to be converted to full, <c>false</c>
    if it wants to prevent the file from being converted to full.</para>
            </returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedFileModifiedOrDeletedCallback">
            <summary>
Indicates that a handle has been closed on the file or directory, and whether the file was modified
while that handle was open, or that the file or directory was deleted as part of closing the handle.
</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyFileHandleClosedFileModifiedOrDeleted</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileHandleClosedFileModified" />
    or <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileHandleClosedFileDeleted" /> when it started the virtualization instance.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory.</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory,
    <c>false</c> if <paramref name="relativePath" /> is for a file.</param>
            <param name="isFileModified">
                <c>true</c> if the file or directory was modified while the handle
    was open, <c>false</c> otherwise.</param>
            <param name="isFileDeleted">
                <c>true</c> if the file or directory was deleted as part of closing
    the handle, <c>false</c> otherwise.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyFileHandleClosedNoModificationCallback">
            <summary>
Indicates that a handle has been closed on the file or directory, and that the file was not modified
while that handle was open, and that the file or directory was not deleted as part of closing the handle.
</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyFileHandleClosedNoModification</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileHandleClosedNoModification" />
    when it started the virtualization instance.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory.</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory,
    <c>false</c> if <paramref name="relativePath" /> is for a file.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyHardlinkCreatedCallback">
            <summary>Indicates that a hard link has been created for the file.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyHardlinkCreated</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.HardlinkCreated" />
    when it started the virtualization instance.</para>
                <para>If both the <paramref name="relativePath" /> and <paramref name="destinationPath" />
    parameters of this callback are non-empty strings, this indicates that the new hard link
    was created under the virtualization root for a file that exists under the virtualization
    root.  If the provider specified different notification masks in the <paramref name="notificationMappings" />
    parameter of <c>ProjFS.VirtualizationInstance.StartVirtualizing</c> for the source and
    destination paths, then ProjFS will send this notification if the provider specified
    <see cref="F:Microsoft.Windows.ProjFS.NotificationType.HardlinkCreated" /> when registering either the source or destination
    paths.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file for
    which the hard link was created.
    <para>This parameter will be "" to indicate that the hard link name was created under the
    virtualization root, i.e. a new hard link was created under the virtualization to a file
    that exists in a location not under the virtualization root.</para></param>
            <param name="destinationPath">The path, relative to the virtualization root, of the new hard
    link name.
    <para>This parameter will be "" to indicate that the hard link name was created in a
    location not under the virtualization root, i.e. a new hard link was created in a location
    not under the virtualization root for a file that is under the virtualization root.</para></param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyFileRenamedCallback">
            <summary>
Indicates that a file or directory has been renamed.  The file or directory may have been moved
into the virtualization instance.
</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyFileRenamed</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileRenamed" />
    when it started the virtualization instance.</para>
                <para>If both the <paramref name="relativePath" /> and <paramref name="destinationPath" />
    parameters of this callback are non-empty strings, this indicates that the source and
    destination of the rename were both under the virtualization root.  If the provider specified
    different notification masks in the <paramref name="notificationMappings" /> parameter of
    <c>ProjFS.VirtualizationInstance.StartVirtualizing</c> for the source and destination
    paths, then ProjFS will send this notification if the provider specified
    <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileRenamed" /> when registering either the source or destination
    paths.</para>
            </remarks>
            <param name="relativePath">The original path, relative to the virtualization root, of the file
    or directory that was renamed.
    <para>This parameter will be "" to indicate that the rename moved the file or directory
    from outside the virtualization instance.  In that case ProjFS will always send this notification
    if the provider has implemented this callback, even if the provider did not specify <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileRenamed" />
    when registering the subtree containing the destination path.
    </para></param>
            <param name="destinationPath">The path, relative to the virtualization root, to which the file
    or directory was renamed.
    <para>This parameter will be "" to indicate that the rename moved the file or directory
    out of the virtualization instance.
    </para></param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory,
    <c>false</c> if <paramref name="relativePath" /> is for a file.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <param name="notificationMask">Upon return from this callback specifies a bitwise-OR of
    <see cref="T:Microsoft.Windows.ProjFS.NotificationType" /> values indicating the set of notifications the provider
    wishes to receive for this file.
    <para>If the provider sets this value to 0, it is equivalent to specifying <see cref="F:Microsoft.Windows.ProjFS.NotificationType.UseExistingMask" />.</para></param>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyPreCreateHardlinkCallback">
            <summary>Indicates that a hard link is about to be created for the file.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyPreCreateHardlink</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.PreCreateHardlink" />
    when it started the virtualization instance.</para>
                <para>If both the <paramref name="relativePath" /> and <paramref name="destinationPath" />
    parameters of this callback are non-empty strings, this indicates that the new hard link
    will be created under the virtualization root for a file that is under the virtualization
    root.  If the provider specified different notification masks in the
    <paramref name="notificationMappings" /> parameter of <c>ProjFS.VirtualizationInstance.StartVirtualizing</c>
    for the source and destination paths, then ProjFS will send this notification if the provider
    specified <see cref="F:Microsoft.Windows.ProjFS.NotificationType.PreCreateHardlink" /> when registering either the
    source or destination paths.</para>
                <para>If the provider returns <c>false</c>, then the file system will return STATUS_ACCESS_DENIED
    from the hard link operation, and the hard link will not be created.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory
    for which the hard link is to be created.
    <para>This parameter will be "" to indicate that the hard link name will be created under
    the virtualization root, i.e. a new hard link is being created under the virtualization
    root to a file whose path is not under the virtualization root.</para></param>
            <param name="destinationPath">The path, relative to the virtualization root, of the new hard
    link name.
    <para>This parameter will be "" to indicate that the hard link name will be created in
    a location not under the virtualization, i.e. a new hard link is being created in a location
    not under the virtualization for a file is under the virtualization root.</para></param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <returns>
                <para>
                    <c>true</c> if the provider wants to allow the hard link operation to happen, false
    if it wants to prevent the hard link operation.</para>
            </returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyPreRenameCallback">
            <summary>Indicates that a file or directory is about to be renamed.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyPreRename</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.PreRename" />
    when it started the virtualization instance.</para>
                <para>If both the <paramref name="relativePath" /> and <paramref name="destinationPath" />
    parameters of this callback are non-empty strings, this indicates that the source and
    destination of the rename are under the virtualization root.  If the provider specified
    different notification masks in the <paramref name="notificationMappings" /> parameter of
    <c>ProjFS.VirtualizationInstance.StartVirtualizing</c> for the source and destination
    paths, then ProjFS will send this notification if the provider specified
    <see cref="F:Microsoft.Windows.ProjFS.NotificationType.PreRename" /> when registering either the source or destination
    paths.</para>
                <para>If the provider returns <c>false</c>, then the file system will return STATUS_ACCESS_DENIED
    from the rename operation, and the rename will not take effect.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory
    to be renamed.
    <para>This parameter will be "" to indicate that the rename will move the file or directory
    from a location not under the virtualization root.  In that case ProjFS will always send
    this notification if the provider has implemented this callback, even if the provider did
    not specify <see cref="F:Microsoft.Windows.ProjFS.NotificationType.PreRename" /> when registering the subtree containing
    the destination path.
    </para></param>
            <param name="destinationPath">The path, relative to the virtualization root, to which the file
    or directory will be renamed.
    <para>This parameter will be "" to indicate that the rename will move the file or directory
    out of the virtualization instance.
    </para></param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <returns>
                <para>
                    <c>true</c> if the provider wants to allow the rename to happen, false if it wants
    to prevent the rename.</para>
            </returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyPreDeleteCallback">
            <summary>Indicates that a file or directory is about to be deleted.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyPreDelete</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.PreDelete" />
    when it started the virtualization instance.</para>
                <para>If the provider returns <c>false</c> then the file system will return STATUS_CANNOT_DELETE
    from the operation that triggered the delete, and the delete will not take place.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory.</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory,
    <c>false</c> if <paramref name="relativePath" /> is for a file.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <returns>
                <para>
                    <c>true</c> if the provider wants to allow the delete to happen, false if it wants
    to prevent the delete.</para>
            </returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyFileOverwrittenCallback">
            <summary>Indicates that an existing file has been superseded or overwritten.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyFileOverwritten</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileOverwritten" />
    when it started the virtualization instance.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory.</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory,
    <c>false</c> if <paramref name="relativePath" /> is for a file.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <param name="notificationMask">Upon return from this callback specifies a bitwise-OR of
    <see cref="T:Microsoft.Windows.ProjFS.NotificationType" /> values indicating the set of notifications the provider
    wishes to receive for this file.
    <para>If the provider sets this value to 0, it is equivalent to specifying <see cref="F:Microsoft.Windows.ProjFS.NotificationType.UseExistingMask" />.</para></param>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyNewFileCreatedCallback">
            <summary>Indicates that a new file or directory has been created.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyNewFileCreated</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.NewFileCreated" />
    when it started the virtualization instance.</para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory.</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory,
    <c>false</c> if <paramref name="relativePath" /> is for a file.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <param name="notificationMask">Upon return from this callback specifies a bitwise-OR of
    <see cref="T:Microsoft.Windows.ProjFS.NotificationType" /> values indicating the set of notifications the provider
    wishes to receive for this file.
    <para>If the provider sets this value to 0, it is equivalent to specifying <see cref="F:Microsoft.Windows.ProjFS.NotificationType.UseExistingMask" />.</para></param>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotifyFileOpenedCallback">
            <summary>Indicates that a handle has been created to an existing file or directory.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnNotifyFileOpened</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>
    ProjFS will invoke this callback if the provider registered for <see cref="F:Microsoft.Windows.ProjFS.NotificationType.FileOpened" />
    when it started the virtualization instance.
    </para>
                <para>
    If the provider returns <c>false</c>, then the file system will cancel the open of the file and
    return STATUS_ACCESS_DENIED to the caller trying to open the file.
    </para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file or directory.</param>
            <param name="isDirectory">
                <c>true</c> if <paramref name="relativePath" /> is for a directory,
    <c>false</c> if <paramref name="relativePath" /> is for a file.</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <param name="notificationMask">Upon return from this callback specifies a bitwise-OR of
    <see cref="T:Microsoft.Windows.ProjFS.NotificationType" /> values indicating the set of notifications the provider
    wishes to receive for this file.
    <para>If the provider sets this value to 0, it is equivalent to specifying <see cref="F:Microsoft.Windows.ProjFS.NotificationType.UseExistingMask" />.</para></param>
            <returns>
                <para>
                    <c>true</c> if the provider wants to allow the opened file to be returned to the
    caller, <c>false</c> otherwise.</para>
            </returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.CancelCommandCallback">
            <summary>Informs the provider that an operation begun by an earlier invocation of a callback
is to be canceled.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnCancelCommand</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>
    ProjFS invokes this callback to indicate that the I/O that caused the earlier callback
    to be invoked was canceled, either explicitly or because the thread it was issued on terminated.
    </para>
                <para>
    Calling <c>ProjFS.VirtualizationInstance.CompleteCommand</c> for the <paramref name="commandId" />
    passed by this callback is not an error, however it is a no-op because the I/O that caused
    the callback invocation identified by <paramref name="commandId" /> has already ended.
    </para>
                <para>
    ProjFS will invoke this callback for a given <paramref name="commandId" /> only after
    the callback to be canceled is invoked.  However if the provider is configured to allow
    more than one concurrently running worker thread, the cancellation and original invocation
    may run concurrently.  The provider must be able to handle this situation.
    </para>
                <para>
    A provider that does not return <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> to any of its callbacks does
    not need to handle this callback.
    </para>
            </remarks>
            <param name="commandId">A value that identifies the callback invocation to be canceled.
Corresponds to the <paramref name="commandId" /> parameter of callbacks whose processing
can be canceled.</param>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.QueryFileNameCallback">
            <summary>Determines whether a given file path exists in the provider's store.</summary>
            <remarks>
                <para>
    The provider sets its implementation of this delegate into the <c>OnQueryFileName</c>
    property of <c>ProjFS.VirtualizationInstance</c>.
    </para>
                <para>
    If the provider does not implement this callback, ProjFS will call the enumeration callbacks
    when it needs to find out whether a file path exists in the providerâ€™s store.
    </para>
            </remarks>
            <param name="relativePath">The path, relative to the virtualization root, of the file being queried.</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if <paramref name="relativePath" /> exists in the provider's store.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> if <paramref name="relativePath" /> does not exist in the provider's store.</para>
                <para>An appropriate error code if the provider fails the operation.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetFileDataCallback(System.Int32,System.String,System.UInt64,System.UInt32,System.Guid,System.Byte[],System.Byte[],System.UInt32,System.String)">
            <summary>Requests the contents of a file's primary data stream.</summary>
            <remarks>
                <para>ProjFS uses the data the provider provides in this callback to convert the file into
    a hydrated placeholder.</para>
                <para>To handle this callback, the provider issues one or more calls to
    <c>ProjFS.VirtualizationInstance.WriteFile</c> to give ProjFS the contents of the file's
    primary data stream.  Then the provider completes the callback.</para>
            </remarks>
            <param name="commandId">A value that uniquely identifies an invocation of the callback.
    <para>If the provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> from this method, then it must pass
    this value to <c>ProjFS.VirtualizationInstance.CompleteCommand</c> to signal that it has
    finished processing this invocation of the callback.</para></param>
            <param name="relativePath">The path, relative to the virtualization root, of the file for
which to provide data.</param>
            <param name="byteOffset">Offset in bytes from the beginning of the file at which the provider
    must start returning data.  The provider must return file data starting at or before this
    offset.</param>
            <param name="length">Number of bytes of file data requested.  The provider must return at least
    this many bytes of file data beginning at <paramref name="byteOffset" />.</param>
            <param name="dataStreamId">The unique value to associate with this file stream.  The provider
    must pass this value to <c>ProjFS.VirtualizationInstance.WriteFile</c> when providing
    file data as part of handling this callback.</param>
            <param name="contentId">The <paramref name="contentId" /> value specified by the provider when
    it created the placeholder for this file.  See <c>ProjFS.VirtualizationInstance.WritePlaceholderInfo</c>.</param>
            <param name="providerId">The <paramref name="providerId" /> value specified by the provider when
    it created the placeholder for this file.  See <c>ProjFS.VirtualizationInstance.WritePlaceholderInfo</c>.</param>
            <param name="triggeringProcessId">The PID for the process that triggered this callback.  If
this information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to
<paramref name="triggeringProcessId" />.  If <paramref name="triggeringProcessId" /> is 0 this
will be <c>null</c>.</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the provider successfully wrote all the requested data.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> if the provider wishes to complete the operation at a later time.</para>
                <para>An appropriate error code if the provider fails the operation.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetPlaceholderInfoCallback(System.Int32,System.String,System.UInt32,System.String)">
            <summary>Requests metadata information for a file or directory from the provider.</summary>
            <remarks>
                <para>ProjFS uses the information the provider provides in this callback to create a
    placeholder for the requested item.</para>
                <para>To handle this callback, the provider typically calls
    <c>ProjFS.VirtualizationInstance.WritePlaceholderInfo</c> to give ProjFS the information
    for the requested file name.  Then the provider completes the callback.</para>
            </remarks>
            <param name="commandId">
                <para>A value that uniquely identifies an invocation of the callback.</para>
                <para>If the provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> from this method, then it must pass
    this value to <c>ProjFS.VirtualizationInstance.CompleteCommand</c> to signal that it has
    finished processing this invocation of the callback.</para>
            </param>
            <param name="relativePath">The path, relative to the virtualization root, of the file for
which to return information.</param>
            <param name="triggeringProcessId">The PID for the process that triggered this callback.  If
this information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to
<paramref name="triggeringProcessId" />. If <paramref name="triggeringProcessId" /> is 0 this
will be <c>null</c>.</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the file exists in the provider's store and it successfully
    gave the file's information to ProjFS.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /> if <paramref name="relativePath" /> does not exist in the provider's store.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> if the provider wishes to complete the operation at a later time.</para>
                <para>An appropriate error code if the provider fails the operation.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.EndDirectoryEnumerationCallback(System.Guid)">
            <summary>
Informs the provider that a directory enumeration is over.
</summary>
            <seealso cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.StartDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.UInt32,System.String)" />
            <seealso cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.Boolean,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)" />
            <remarks>
                <para>
    ProjFS requests a directory enumeration from the provider by first invoking
    <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.StartDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.UInt32,System.String)" />, then the
    <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.Boolean,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)" /> callback one or more times, then this
    callback.  Because multiple enumerations may occur in parallel in the same location,
    ProjFS uses the <paramref name="enumerationId" /> argument to associate the callback
    invocations into a single enumeration, meaning that a given set of calls to the enumeration
    callbacks will use the same value for <paramref name="enumerationId" /> for the same session.
    </para>
            </remarks>
            <param name="enumerationId">Identifies this enumeration session.</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the provider successfully completes the operation.</para>
                <para>An appropriate error code if the provider fails the operation.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.Boolean,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)">
            <summary>
Requests directory enumeration information from the provider.
</summary>
            <seealso cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.StartDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.UInt32,System.String)" />
            <seealso cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.EndDirectoryEnumerationCallback(System.Guid)" />
            <remarks>
                <para>
    ProjFS requests a directory enumeration from the provider by first invoking
    <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.StartDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.UInt32,System.String)" />, then this callback one or more times,
    then the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.EndDirectoryEnumerationCallback(System.Guid)" /> callback.  Because multiple
    enumerations may occur in parallel in the same location, ProjFS uses the
    <paramref name="enumerationId" /> argument to associate the callback invocations into a
    single enumeration, meaning that a given set of calls to the enumeration callbacks will
    use the same value for <paramref name="enumerationId" /> for the same session.
    </para>
                <para>
    The provider must store the value of <paramref name="filterFileName" /> across calls
    to this callback.  The provider replaces the value of <paramref name="filterFileName" />
    if <paramref name="restartScan" /> in a subsequent invocation of the callback is <c>true</c></para>
                <para>If no entries match the search expression specified in <paramref name="filterFileName" />,
    or if all the entries in the directory were added in a previous invocation of this callback,
    the provider must return <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" />.</para>
            </remarks>
            <param name="commandId">
                <para>A value that uniquely identifies an invocation of the callback.</para>
                <para>If the provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> from this method, then it must pass
    this value to <c>ProjFS.VirtualizationInstance.CompleteCommand</c> to signal that it has
    finished processing this invocation of the callback.</para>
            </param>
            <param name="enumerationId">Identifies this enumeration session.</param>
            <param name="filterFileName">
                <para>An optional string specifying a search expression.  This parameter may be <c>null</c>.</para>
                <para>The search expression may include wildcard characters.  The provider should use the
    <c>ProjFS.Utils.DoesNameContainWildCards</c> method routine to determine whether wildcards
    are present in the search expression.  The provider should use the <c>ProjFS.Utils.IsFileNameMatch</c>
    method to determine whether a directory entry in its store matches the search expression.</para>
                <para>If this parameter is not <c>null</c>, only files whose names match the search expression
    should be included in the directory scan.</para>
                <para>If this parameter is <c>null</c>, all entries in the directory must be included.</para>
            </param>
            <param name="restartScan">
                <para>
                    <c>true</c> if the scan is to start at the first entry in the directory.</para>
                <para>
                    <c>false</c> if resuming the scan from a previous call.</para>
                <para>On the first invocation of this callback for an enumeration session the provider must
    treat this as <c>true</c>, regardless of its value (i.e. all enumerations must start at the
    first entry).  On subsequent invocations of this callback the provider must honor this value.</para>
            </param>
            <param name="result">
                <para>Receives the results of the enumeration from the provider.</para>
                <para>The provider uses one of the <see cref="T:Microsoft.Windows.ProjFS.IDirectoryEnumerationResults" />::<c>Add</c>
    methods of this object to provide the enumeration results.</para>
                <para>If the provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> from this method, then it must pass
    this value to <c>ProjFS.VirtualizationInstance.CompleteCommand</c> to provide the
    enumeration results.</para>
            </param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the provider successfully completes the operation.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> if the provider wishes to complete the operation at a later time.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.InsufficientBuffer" /> if <paramref name="result" /><c>.Add</c> returned
    <see cref="F:Microsoft.Windows.ProjFS.HResult.InsufficientBuffer" /> for the first matching file or directory in the enumeration.</para>
                <para>An appropriate error code if the provider fails the operation.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.StartDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.UInt32,System.String)">
            <summary>
Informs the provider that a directory enumeration is starting.
</summary>
            <seealso cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.Boolean,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)" />
            <seealso cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.EndDirectoryEnumerationCallback(System.Guid)" />
            <remarks>
                <para>
    ProjFS requests a directory enumeration from the provider by first invoking this callback,
    then the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.GetDirectoryEnumerationCallback(System.Int32,System.Guid,System.String,System.Boolean,Microsoft.Windows.ProjFS.IDirectoryEnumerationResults)" /> callback one or more times, then
    the <see cref="M:Microsoft.Windows.ProjFS.IRequiredCallbacks.EndDirectoryEnumerationCallback(System.Guid)" /> callback.  Because multiple enumerations
    may occur in parallel in the same location, ProjFS uses the <paramref name="enumerationId" />
    argument to associate the callback invocations into a single enumeration, meaning that
    a given set of calls to the enumeration callbacks will use the same value for
    <paramref name="enumerationId" /> for the same session.
    </para>
            </remarks>
            <param name="commandId">A value that uniquely identifies an invocation of the callback.
    <para>If the provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> from this method, then it must pass
    this value to <c>ProjFS.VirtualizationInstance.CompleteCommand</c> to signal that it has
    finished processing this invocation of the callback.</para></param>
            <param name="enumerationId">Identifies this enumeration session.</param>
            <param name="relativePath">Identifies the directory to be enumerated.  The path is specified
    relative to the virtualization root.
</param>
            <param name="triggeringProcessId">The PID of the process that triggered this callback. If this
    information is not available, this will be 0.</param>
            <param name="triggeringProcessImageFileName">The image file name corresponding to <paramref name="triggeringProcessId" />.
    If <paramref name="triggeringProcessId" /> is 0 this will be null.</param>
            <returns>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> if the provider successfully completes the operation.</para>
                <para>
                    <see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /> if the provider wishes to complete the operation at a later time.</para>
                <para>An appropriate error code if the provider fails the operation.</para>
            </returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.IRequiredCallbacks">
            <summary>
Defines callbacks that a provider is required to implement.
</summary>
            <remarks>
                <para>
A provider must implement the methods in this class to supply basic file system functionality.
The provider passes a reference to its implementation in the <c>Microsoft.Windows.ProjFS.StartVirtualizing</c>
method.
</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.DirectoryEnumerationResults.Add(System.String,System.Int64,System.Boolean,System.IO.FileAttributes,System.DateTime,System.DateTime,System.DateTime,System.DateTime)">
            <summary>Adds one entry to a directory enumeration result.</summary>
            <remarks>
                <para>
    In its implementation of a <c>GetDirectoryEnumerationCallback</c> delegate the provider
    calls this method for each matching file or directory in the enumeration.
    </para>
                <para>
    If this method returns <c>false</c>, the provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> and waits for
    the next <c>GetDirectoryEnumerationCallback</c>.  Then it resumes filling the enumeration with
    the entry it was trying to add when it got <c>false</c>. 
    </para>
                <para>
    If the method returns <c>false</c> for the first file or directory in the enumeration, the
    provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.InsufficientBuffer" /> from the <c>GetDirectoryEnumerationCallback</c>
    method.
    </para>
            </remarks>
            <param name="fileName">The name of the file or directory.</param>
            <param name="fileSize">The size of the file.</param>
            <param name="isDirectory">
                <c>true</c> if this item is a directory, <c>false</c> if it is a file.</param>
            <param name="fileAttributes">The file attributes.</param>
            <param name="creationTime">The time the file was created.</param>
            <param name="lastAccessTime">The time the file was last accessed.</param>
            <param name="lastWriteTime">The time the file was last written to.</param>
            <param name="changeTime">The time the file was last changed.</param>
            <returns>
                <para>
                    <c>true</c> if the entry was successfully added to the enumeration buffer, <c>false</c> otherwise.
    </para>
            </returns>
            <exception cref="T:System.ArgumentException">
                <paramref name="fileName" /> is null or empty.
</exception>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.DirectoryEnumerationResults.Add(System.String,System.Int64,System.Boolean)">
            <summary>Adds one entry to a directory enumeration result.</summary>
            <remarks>
                <para>
    In its implementation of a <c>GetDirectoryEnumerationCallback</c> delegate the provider
    calls this method for each matching file or directory in the enumeration.
    </para>
                <para>
    If the provider calls this <c>Add</c> overload, then the timestamps reported to the caller
    of the enumeration are the current system time.  If the provider wants the caller to see other
    timestamps, it must use the other <c>Add</c> overload.
    </para>
                <para>
    If this method returns <c>false</c>, the provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /> and waits for
    the next <c>GetDirectoryEnumerationCallback</c>.  Then it resumes filling the enumeration with
    the entry it was trying to add when it got <c>false</c>. 
    </para>
                <para>
    If the method returns <c>false</c> for the first file or directory in the enumeration, the
    provider returns <see cref="F:Microsoft.Windows.ProjFS.HResult.InsufficientBuffer" /> from the <c>GetDirectoryEnumerationCallback</c>
    method.
    </para>
            </remarks>
            <param name="fileName">The name of the file or directory.</param>
            <param name="fileSize">The size of the file.</param>
            <param name="isDirectory">
                <c>true</c> if this item is a directory, <c>false</c> if it is a file.</param>
            <returns>
                <para>
                    <c>true</c> if the entry was successfully added to the enumeration buffer, <c>false</c> otherwise.
    </para>
            </returns>
            <exception cref="T:System.ArgumentException">
                <paramref name="fileName" /> is null or empty.
</exception>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.DirectoryEnumerationResults">
            <summary>Helper class for providing the results of a directory enumeration.</summary>
            <remarks>
ProjFS passes an instance of this class to the provider in the <paramref name="result" />
parameter of its implementation of a <c>GetDirectoryEnumerationCallback</c> delegate.  The provider
calls one of its <c>Add</c> methods for each item in the enumeration
to add it to the result set.
</remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IDirectoryEnumerationResults.Add(System.String,System.Int64,System.Boolean,System.IO.FileAttributes,System.DateTime,System.DateTime,System.DateTime,System.DateTime)">
            <summary>
When overridden in a derived class, adds one entry to a directory enumeration result.
</summary>
            <remarks>
                <para>
In its implementation of a <c>GetDirectoryEnumerationCallback</c> delegate the provider
calls this method for each matching file or directory in the enumeration.
</para>
                <para>
If this method returns <c>false</c>, the provider returns <c>HResult.Ok</c> and waits for
the next <c>GetDirectoryEnumerationCallback</c>.  Then it resumes filling the enumeration with
the entry it was trying to add when it got <c>false</c>. 
</para>
                <para>
If the function returns <c>false</c> for the first file or directory in the enumeration, the
provider returns <c>HResult.InsufficientBuffer</c> from the <c>GetDirectoryEnumerationCallback</c>
method.
</para>
            </remarks>
            <param name="fileName">The name of the file or directory.</param>
            <param name="fileSize">The size of the file.</param>
            <param name="isDirectory">
                <c>true</c> if this item is a directory, <c>false</c> if it is a file.</param>
            <param name="fileAttributes">The file attributes.</param>
            <param name="creationTime">Specifies the time that the file was created.</param>
            <param name="lastAccessTime">Specifies the time that the file was last accessed.</param>
            <param name="lastWriteTime">Specifies the time that the file was last written to.</param>
            <param name="changeTime">Specifies the last time the file was changed.</param>
            <returns>
                <para>
                    <c>true</c> if the entry was successfully added to the enumeration buffer, <c>false</c> otherwise.
</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.IDirectoryEnumerationResults.Add(System.String,System.Int64,System.Boolean)">
            <summary>
When overridden in a derived class, adds one entry to a directory enumeration result.
</summary>
            <remarks>
                <para>
In its implementation of a <c>GetDirectoryEnumerationCallback</c> delegate the provider
calls this method for each matching file or directory in the enumeration.
</para>
                <para>
If this method returns <c>false</c>, the provider returns <c>HResult.Ok</c> and waits for
the next <c>GetDirectoryEnumerationCallback</c>.  Then it resumes filling the enumeration with
the entry it was trying to add when it got <c>false</c>. 
</para>
                <para>
If the function returns <c>false</c> for the first file or directory in the enumeration, the
provider returns <c>HResult.InsufficientBuffer</c> from the <c>GetDirectoryEnumerationCallback</c>
method.
</para>
            </remarks>
            <param name="fileName">The name of the file or directory.</param>
            <param name="fileSize">The size of the file.</param>
            <param name="isDirectory">
                <c>true</c> if this item is a directory, <c>false</c> if it is a file.</param>
            <returns>
                <para>
                    <c>true</c> if the entry was successfully added to the enumeration buffer, <c>false</c> otherwise.
</para>
            </returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.IDirectoryEnumerationResults">
            <summary>
Interface to allow for easier unit testing of a virtualization provider.
</summary>
            <remarks>
This class defines the interface implemented by the <c>Microsoft.Windows.ProjFS.DirectoryEnumerationResults</c>
class.  This interface class is provided for use by unit tests to mock up the interface to ProjFS.
</remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.WriteBuffer.Finalize">
            <summary>
Frees the internal buffer.
</summary>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.WriteBuffer.Pointer">
            <summary>
Gets a pointer to the internal buffer.
</summary>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.WriteBuffer.Stream">
            <summary>
Gets a <see cref="T:System.IO.UnmanagedMemoryStream" /> representing the internal buffer.
</summary>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.WriteBuffer.Length">
            <summary>
Gets the allocated length of the buffer.
</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.WriteBuffer">
            <summary>
Helper class to ensure correct alignment when providing file contents for a placeholder.
</summary>
            <remarks>
                <para>
The provider does not instantiate this class directly.  It uses the 
<c>ProjFS.VirtualizationInstance.CreateWriteBuffer</c> method to obtain a properly initialized
instance of this class.
</para>
                <para>
The <c>ProjFS.VirtualizationInstance.WriteFileData</c> method requires a data buffer containing
file data for a placeholder so that ProjFS can convert the placeholder to a hydrated placeholder
(see <c>ProjFS.OnDiskFileState</c> for a discussion of file states).  Internally ProjFS uses
the user's FILE_OBJECT to write this data to the file.  Because the user may have opened the
file for unbuffered I/O, and unbuffered I/O imposes certain alignment requirements, this
class is provided to abstract out those details.
</para>
                <para>
When the provider starts its virtualization instance, the <c>VirtualizationInstance</c> class
queries the alignment requirements of the underlying physical storage device and uses this
information to return a properly-initialized instance of this class from its <c>CreateWriteBuffer</c>
method.
</para>
            </remarks>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.ApiHelper">
            <summary>Helper class for using the correct native APIs in the managed layer.</summary>
            <remarks>
                <para>
The final ProjFS native APIs released in Windows 10 version 1809 differ from the now-deprecated
beta APIs released in Windows 10 version 1803.  In 1809 the beta APIs are still exported from
ProjectedFSLib.dll, in case an experimental provider written against the native 1803 APIs is run
on 1809.
</para>
                <para>
This managed API wrapper is meant to be usable on 1803 and later, so it is able to use the
beta 1803 native APIs and the final 1809 native APIs.  Since the 1809 APIs are not present on
1803, and because we intend to remove the beta 1803 APIs from a later version of Windows, we
dynamically load the native APIs here.  If we didn't do that then trying to use this managed
wrapper on a version of Windows missing one or the other native API would result in the program
dying on startup with an unhandled <c>System::IO::FileLoadException</c>: "A procedure
imported by 'ProjectedFSLib.Managed.dll' could not be loaded."
</para>
                <para>
It is likely that at some point after removing the beta 1803 native APIs from Windows we will
also remove support for them from this managed wrapper.
</para>
            </remarks>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IWriteBuffer.Pointer">
            <summary>
When overridden in a derived class, gets a pointer to the internal buffer.
</summary>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IWriteBuffer.Stream">
            <summary>
When overridden in a derived class, gets a <see cref="T:System.IO.UnmanagedMemoryStream" />
representing the internal buffer.
</summary>
        </member>
        <member name="P:Microsoft.Windows.ProjFS.IWriteBuffer.Length">
            <summary>
When overridden in a derived class, gets the allocated length of the buffer.
</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.IWriteBuffer">
            <summary>
Interface to allow for easier unit testing of a virtualization provider.
</summary>
            <remarks>
This class defines the interface implemented by the <c>Microsoft.Windows.ProjFS.WriteBuffer</c>
class.  This interface class is provided for use by unit tests to mock up the interface to ProjFS.
</remarks>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.Utils.DoesNameContainWildCards(System.String)">
            <summary>Determines whether a string contains any wildcard characters.</summary>
            <remarks>
                <para>
This routine checks for the wildcard characters recognized by the file system.  These
wildcards are sent by programs such as the cmd.exe command interpreter.
</para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Character</term>
                            <term>Meaning</term>
                        </listheader>
                        <item>
                            <description>*</description>
                            <description>Matches 0 or more characters.</description>
                        </item>
                        <item>
                            <description>?</description>
                            <description>Matches exactly one character.</description>
                        </item>
                        <item>
                            <description>DOS_DOT (")</description>
                            <description>Matches either a ".", or zero characters beyond the name string.</description>
                        </item>
                        <item>
                            <description>DOS_STAR (&lt;)</description>
                            <description>Matches 0 or more characters until encountering and matching the final "." in the name.</description>
                        </item>
                        <item>
                            <description>DOS_QM (&gt;)</description>
                            <description>Matches any single character, or upon encountering a period or end of name string, advances the expression
        to the end of the set of contiguous DOS_QMs.</description>
                        </item>
                    </list>
                </para>
            </remarks>
            <param name="fileName">A string to check for wildcard characters.</param>
            <returns>
                <c>true</c> if <paramref name="fileName" /> contains any wildcard characters,
<c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.Utils.FileNameCompare(System.String,System.String)">
            <summary>
Compares two file names and returns a value that indicates their relative collation order.
</summary>
            <remarks>
The provider may use this routine to determine how to sort file names in the same order
that the file system does.
</remarks>
            <param name="fileName1">The first name to compare.</param>
            <param name="fileName2">The second name to compare.</param>
            <returns>
                <para>A negative number if <paramref name="fileName1" /> is before <paramref name="fileName2" /> in collation order.</para>
                <para>0 if <paramref name="fileName1" /> is equal to <paramref name="fileName2" />.</para>
                <para>A positive number if <paramref name="fileName1" /> is after <paramref name="fileName2" /> in collation order.</para>
            </returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.Utils.IsFileNameMatch(System.String,System.String)">
            <summary>
Determines whether a file name string matches a pattern, potentially containing
wildcard characters, according to the rules used by the file system.
</summary>
            <remarks>
A provider should use this routine in its implementation of the <c>GetDirectoryEnumerationCallback</c>
delegate to determine whether a name it its backing store matches the search expression
from the <c>filterFileName</c> parameter of the <c>GetDirectoryEnumerationCallback</c>
delegate.
</remarks>
            <param name="fileNameToCheck">The file name to check against <paramref name="pattern" />.</param>
            <param name="pattern">The pattern for which to search.</param>
            <returns>
                <c>true</c> if <paramref name="fileNameToCheck" /> matches <paramref name="pattern" />,
<c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Windows.ProjFS.Utils.TryGetOnDiskFileState(System.String,Microsoft.Windows.ProjFS.OnDiskFileState@)">
            <summary>
Returns the on-disk state of the specified file or directory.
</summary>
            <remarks>
                <para>
    This routine tells the caller what the ProjFS caching state is of the specified file or
    directory.  For example, the caller can use this routine to determine whether the given item
    is a placeholder or full file.
    </para>
                <para>
    A running provider should be cautious if using this routine on files or directories within
    one of its virtualization instances, as it may cause callbacks to be invoked in the provider.
    Depending on the design of the provider this may lead to deadlocks.
    </para>
            </remarks>
            <param name="fullPath">Full path of the file or the directory.</param>
            <param name="fileState">On successful return contains a bitwise-OR of <see cref="T:Microsoft.Windows.ProjFS.OnDiskFileState" />
    values describing the file state.</param>
            <returns>
                <c>false</c> if <paramref name="fullPath" /> does not exist.
</returns>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.Utils">
            <summary>
Provides utility methods for ProjFS providers.
</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.OnDiskFileState">
            <summary>Defines values describing the on-disk state of a virtualized file.</summary>
            <remarks>
                <para>
The <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.Tombstone" /> state is used to managed deleted files.  When
a directory is enumerated ProjFS merges the set of local items (placeholders, full files,
etc.) with the set of virtual items projected by the provider's <c>IRequiredCallbacks::GetDirectoryEnumerationCallback</c>
method.  If an item appears in both the local and projected sets, the local item takes precedence.
If a file does not exist there is no local state, so it would appear in the enumeration.
However if that item had been deleted, having it appear in the enumeration would be unexpected.
ProjFS deals with this by replacing a deleted item with a special hidden placeholder called
a "tombstone".  This has the following effects:
<list type="bullet"><item><description>Enumerations do not reveal the item.</description></item><item><description>File opens that expect the item to exist fail with e.g. "file not found".</description></item><item><description>File creates that expect to succeed only if the item does not exist succeed;
        ProjFS removes the tombstone as part of the operation.</description></item></list></para>
                <para>
To illustrate the on-disk states consider the following sequence, given a ProjFS provider
that has a single file "foo.txt" located in the virtualization root C:\root.
<list type="number"><item><description>An app enumerates <c>C:\root</c>.  It sees the virtual file "foo.txt".  Since the
        file has not yet been accessed, the file does not exist on disk.</description></item><item><description>The app opens a handle to <c>C:\root\foo.txt</c>.  ProjFS tells the provider to
        create a placeholder for it.  The file's state is now <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.Placeholder" /></description></item><item><description>The app reads the content of the file.  The provider provides the file
        content to ProjFS and it is cached to <c>C:\root\foo.txt</c>.  The file's state is
        now <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.Placeholder" /> | <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.HydratedPlaceholder" />.</description></item><item><description>The app updates the Last Modified timestamp.  The file's state is now
        <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.Placeholder" /> | <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.HydratedPlaceholder" /> | <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.DirtyPlaceholder" />.</description></item><item><description>The app writes some new data to the file.  <c>C:\root\foo.txt</c>'s state
        is now <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.Full" />.</description></item><item><description>The app deletes <c>C:\root\foo.txt</c>.  ProjFS replaces the file with a tombstone,
        so its state is now <see cref="F:Microsoft.Windows.ProjFS.OnDiskFileState.Tombstone" />.
        Now when the app enumerates <c>C:\root</c> it does not see foo.txt.  If it tries to open the
        file, the open fails with <c>HResult.FileNotFound</c>.</description></item></list></para>
            </remarks>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.OnDiskFileState.Tombstone">
            <summary>
A special hidden placeholder that represents an item that has been deleted from the local
file system.
</summary>
            <summary>
The item was a tombstone and the provider did not specify <c>UpdateType.AllowTombstone</c>.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.OnDiskFileState.Full">
            <summary>
The item's content (primary data stream) has been modified.  The file is no longer a cache
of its state in the provider's store.  Files that have been created on the local file
system (i.e.that do not exist in the provider's store at all) are also considered to be
full files.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.OnDiskFileState.DirtyPlaceholder">
            <summary>
The item's metadata has been locally modified and is no longer a cache of its state in
the provider's store. Note that creating or deleting a file or directory under a placeholder
directory causes that placeholder directory to become dirty.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.OnDiskFileState.HydratedPlaceholder">
            <summary>
The item's content and metadata have been cached to the disk.  Also referred to as a 
"partial file/directory".
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.OnDiskFileState.Placeholder">
            <summary>
The item's content (primary data stream) is not present on the disk.  The item's metadata
(name, size, timestamps, attributes, etc.) is cached on the disk.
</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.HResult">
            <summary>
HRESULT values that ProjFS may report to a provider, or that a provider may return to ProjFS.
</summary>
            <remarks>
                <para>
.NET methods normally do not return error codes, preferring to throw exceptions.  For the most
part this API does not throw exceptions, preferring instead to return error codes.  We do this
for few reasons:
<list type="bullet"><item><description>
    This API is a relatively thin wrapper around a native API that itself returns HRESULT codes.
    This managed library would have to translate those error codes into exceptions to throw.
    </description></item><item><description>
    Errors that a provider returns are sent through the file system, back to the user who is
    performing the I/O.  If the provider callbacks threw exceptions, the managed library would
    just have to catch them and turn them into HRESULT codes.
    </description></item><item><description>
    If the API methods described here threw exceptions, either the provider would have to catch
    them and turn them into error codes to return from its callbacks, or it would allow those
    exceptions to propagate and this managed library would still have to deal with them as
    described in the preceding bullet.
    </description></item></list>
So rather than deal with the overhead of exceptions just to try to conform to .NET conventions,
this API largely dispenses with them and uses HRESULT codes.
</para>
                <para>
Note that for the convenience of C# developers the <c>VirtualizationInstance::CreateWriteBuffer</c>
method does throw <c>System::OutOfMemoryException</c> if it cannot allocate the buffer.  This
makes the method convenient to use with the <c>using</c> keyword.
</para>
                <para>
Note that when HRESULT codes returned from the provider are sent to the file system, the ProjFS
library translates them into NTSTATUS codes.  Because there is not a 1-to-1 mapping of HRESULT
codes to NTSTATUS codes, the set of HRESULT codes that a provider is allowed to return is
necessarily constrained.
</para>
                <para>
A provider's <c>IRequiredCallbacks</c> method and <c>On...</c> delegate implementations may
return any <c>HResult</c> value returned from a <c>VirtualizationInstance</c>, as well as the
following <c>HResult</c> values:
<list type="bullet"><item><description><see cref="F:Microsoft.Windows.ProjFS.HResult.Ok" /></description></item><item><description><see cref="F:Microsoft.Windows.ProjFS.HResult.Pending" /></description></item><item><description><see cref="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory" /></description></item><item><description><see cref="F:Microsoft.Windows.ProjFS.HResult.InsufficientBuffer" /></description></item><item><description><see cref="F:Microsoft.Windows.ProjFS.HResult.FileNotFound" /></description></item><item><description><see cref="F:Microsoft.Windows.ProjFS.HResult.VirtualizationUnavaliable" /></description></item><item><description><see cref="F:Microsoft.Windows.ProjFS.HResult.InternalError" /></description></item></list></para>
                <para>
The remaining values in the <c>HResult</c> enum may be returned to a provider from ProjFS APIs
and are primarily intended to communicate information to the provider.  As noted above, if
such a value is returned to a provider in its implementation of a callback or delegate, it may
return the value to ProjFS.
</para>
            </remarks>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.VirtualizationInvalidOp">
            <summary>The virtualization operation is not allowed on the file in its current state.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.ReparsePointEncountered">
            <summary>The object manager encountered a reparse point while retrieving an object.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.PathNotFound">
            <summary>The system cannot find the path specified.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.InvalidArg">
            <summary>One or more arguments are invalid.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.Handle">
            <summary>Invalid handle (it may already be closed).</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.DirNotEmpty">
            <summary>The directory is not empty.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.Directory">
            <summary>The directory name is invalid (it may not be a directory).</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.CannotDelete">
            <summary>An attempt has been made to remove a file or directory that cannot be deleted.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.AccessDenied">
            <summary>Access is denied.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.AlreadyInitialized">
            <summary>An attempt was made to perform an initialization operation when initialization
has already been completed.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.InternalError">
            <summary>The provider is in an invalid state that prevents it from servicing the callback
(only use this if none of the other error codes is a better match).</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.VirtualizationUnavaliable">
            <summary>The provider that supports file system virtualization is temporarily unavailable.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.FileNotFound">
            <summary>The system cannot find the file specified.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.InsufficientBuffer">
            <summary>The data area passed to a system call is too small.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.OutOfMemory">
            <summary>Ran out of memory.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.Pending">
            <summary>The data necessary to complete this operation is not yet available.</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.HResult.Ok">
            <summary>Success.</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.UpdateType">
            <summary>Defines values describing when to allow a virtualized file to be deleted or updated.</summary>
            <remarks>
                <para>
These values are used in the <paramref name="updateFlags" /> input parameter of 
<c>ProjFS.VirtualizationInstance.UpdateFileIfNeeded</c> and <c>ProjFS.VirtualizationInstance.DeleteFile</c>.
The flags control whether ProjFS should allow the update given the state of the file or directory on disk.
</para>
                <para>
See the documentation for <c>ProjFS.OnDiskFileState</c> for a description of possible file
and directory states in ProjFS.
</para>
            </remarks>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateType.AllowReadOnly">
            <summary>
ProjFS will allow the update regardless of whether the DOS read-only bit is set on the item.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateType.AllowTombstone">
            <summary>
ProjFS will allow the update if the item is a placeholder or is a tombstone.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateType.AllowDirtyData">
            <summary>
ProjFS will allow the update if the item is a placeholder or is a full file.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.UpdateType.AllowDirtyMetadata">
            <summary>
ProjFS will allow the update if the item is a placeholder or a dirty placeholder (whether hydrated or not).
</summary>
        </member>
        <member name="T:Microsoft.Windows.ProjFS.NotificationType">
            <summary>
Defines values for file system operation notifications ProjFS can send to a provider.
</summary>
            <remarks>
                <para>
    ProjFS can send notifications of file system activity to a provider.  When the provider
    starts a virtualization instance it specifies which notifications it wishes to receive.
    It may also specify a new set of notifications for a file when it is created or renamed.
    The provider must set implementations of <c>Notify...Callback</c> delegates in the <c>OnNotify...</c>
    properties of <c>ProjFS.VirtualizationInstance</c> in order to receive the notifications
    for which it registers.
    </para>
                <para>
    ProjFS sends notifications for files and directories managed by an active virtualization
    instance. That is, ProjFS will send notifications for the virtualization root and its
    descendants.  Symbolic links and junctions within the virtualization root are not traversed
    when determining what constitutes a descendant of the virtualization root.
    </para>
                <para>
    ProjFS sends notifications only for the primary data stream of a file.  ProjFS does not
    send notifications for operations on alternate data streams.
    </para>
                <para>
    ProjFS does not send notifications for an inactive virtualization instance.  A virtualization
    instance is inactive if any one of the following is true:
        <list type="bullet"><item><description>
                The provider has not yet started it by calling <c>ProjFS.VirtualizationInstance.StartVirtualizing</c>.
                </description></item><item><description>
                The provider has stopped the instance by calling <c>ProjFS.VirtualizationInstance.StopVirtualizing</c>.
                </description></item><item><description>
                The provider process has exited.
                </description></item></list></para>
                <para>
    The provider may specify which notifications it wishes to receive when starting a virtualization
    instance, or in response to a notification that allows a new notification mask to be set.
    The provider specifies a default set of notifications that it wants ProjFS to send for the
    virtualization instance when it starts the instance.  The provider specifies the default
    notifications via the <paramref name="notificationMappings" /> parameter of the
    <c>ProjFS.VirtualizationInstance</c> constructor, which may specify different notification
    masks for different subtrees of the virtualization instance.
    </para>
                <para>
    The provider may choose to supply a different notification mask in response to a notification
    of file open, create, overwrite, or rename.  ProjFS will continue to send these notifications
    for the given file until all handles to the file are closed.  After that it will revert
    to the default set of notifications.  Naturally if the default set of notifications does
    not specify that ProjFS should notify for open, create, etc., the provider will not get
    the opportunity to specify a different mask for those operations.
    </para>
            </remarks>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.UseExistingMask">
            <summary>
This value is not used when calling the <c>VirtualizationInstance</c> constructor.  It
is only returned from <c>OnNotify...</c> callbacks that have a <paramref name="notificationMask" />
parameter, and indicates that the provider wants to continue to receive the notifications
it registered for when starting the virtualization instance.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.FilePreConvertToFull">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyFilePreConvertToFull</c> callback when it is about to convert a placeholder to a full file.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.FileHandleClosedFileDeleted">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyFileHandleClosedFileModifiedOrDeleted</c> callback when a handle is closed on a file or
directory and it is deleted as part of closing the handle.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.FileHandleClosedFileModified">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyFileHandleClosedFileModifiedOrDeleted</c> callback when a handle is closed on a file or
directory and the closing handle was used to modify it.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.FileHandleClosedNoModification">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyFileHandleClosedNoModification</c> callback when a handle is closed on a file or directory
and the closing handle neither modified nor deleted it.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.HardlinkCreated">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyHardlinkCreated</c> callback when a hard link has been created for a file.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.FileRenamed">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyFileRenamed</c> callback when a file or directory has been renamed.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.PreCreateHardlink">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyPreCreateHardlink</c> callback when a hard link is about to be created for a file.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.PreRename">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyPreRename</c> callback when a file or directory is about to be renamed.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.PreDelete">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyPreDelete</c> callback when a file or directory is about to be deleted.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.FileOverwritten">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyFileOverwritten</c> callback when an existing file is superseded or overwritten.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.NewFileCreated">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyNewFileCreated</c> callback when a new file or directory is created.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.FileOpened">
            <summary>
Indicates that ProjFS should call the provider's <c>OnNotifyFileOpened</c> callback when a handle is created to an existing file or directory.
</summary>
        </member>
        <member name="F:Microsoft.Windows.ProjFS.NotificationType.None">
            <summary>
Indicates that the provider does not want any notifications.  This value overrides all others.
</summary>
        </member>
    </members>
</doc>